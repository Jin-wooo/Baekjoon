<BarkingDog님의 알고리즘 강의로 풀게 된 문제>
https://www.acmicpc.net/problem/11728

배열 합치기.
정렬된 두 배열을 정렬된 상태로 합쳐서 출력하는 문제이다.

사실 굉장히 쉬운 문제인데,
이 문제에서 핵심은 각각의 배열이 백만개까지 가능하다는 점이다.
그래서 빠른 A+B와 같은 입력과 출력의 속도 문제에 직면하게 된다.
이 부분에 신경쓰지 않으면 시간 초과한테 계속 얻어맞는다.

그리고 하필 이걸 풀기 시작한 날이 코틀린으로만 알고리즘을 풀어보겠다고 다짐한 날이지... C++에서는 cin / cout을 더 빠르게 입력할 수 있게 만드는 방법을 이미 적용하고 있었지만, 여기서는 그런 부분을 전혀 모르기 때문에 더 시간이 걸렸던 것 같다. 그래도 이번 기회에 제대로 공부하게 되었으니 그렇게 생각하면 차라리 좋은 기회였을지도 모른다.



<코드 설명>
딱히 설명할만한 물건은 아닌 것 같긴 한데...
결국 핵심은 두 배열에 각각 포인터를 두고 포인터가 가리키는 숫자가 더 작은 쪽을 배열에 저장하고, 해당 인덱스는 1 늘리는 것을 반복하는 방식으로 풀었다. 이 때 둘 중 어느 한 쪽이 끝에 도달하면 더 이상은 비교할 수가 없게 되는데(어느 한 쪽이 끝에 도착했으면 읽을 숫자가 없으니까), 그 때는 다른 한 쪽의 나머지 숫자들을 전부 정답을 저장하는 배열에 넣는 방식으로 해결했다.

이 방식도 결국은 O(N + M)(N과 M은 각각 두 배열의 길이)지만,
barkingdog님은 좀 더 쉽고 단순한 방식으로 해결했다.
정답 배열의 인덱스를 누가 채울 것인가? 를 기준으로 잡았다고 해야 할까?

for문으로 0부터 N + M까지 숫자를 돌려서 그 자리에 어떤 숫자가 와야 할지를 하나하나 넣는 방식이라고 생각하면 된다.
이러면 내가 풀었던 것처럼 if문을 번거롭게 쓰지 않아도 for문 하나에 if문 몇 개만 달아둬도 자연스럽게 해결이 된다.
궁금하다면 
https://github.com/encrypted-def/basic-algo-lecture/blob/master/0x0E/11728.cpp
이 링크를 통해 가서 직접 보는 편이 나을 것 같다.



코드에서 꼭 봐야 하는 부분은 속도를 위한 부분과 입출력 부분인데,
입력의 경우 이전에는 그냥 nextInt를 썼었는데, 알고보니 이 방식은 
with(Scanner(System.`in`))이 없으면 사용할 수 없는 방식인데다가 느리기까지 하다고 한다.

그래서 with(System.`in`.bufferedReader())를 통해 main 함수가 빠른 속도를 가진 bufferedReader의 함수들을 꺼내쓸 수 있게 만들었다.
(잘 보면 둘 다 with를 통해서 뭔가를 불러오고 있는데, 이렇게 하면 System.`in`.bufferedReader() 객체를 생성하지 않고도 그냥 관련 함수들을 호출 가능하다. 바로 아랫줄의 readLine()들이 그런 예시.)


또한 출력은 BufferedWriter 타입의 객체로 만들어주었다. 이 BufferedWriter는 이전의 println처럼 매번 출력하는 방식이 아니라 버퍼에 출력물들을 모았다가 한 번에 출력하는 방식이라서 좀 더 빠른 출력이 가능하다고 한다. 
(이전에 출력할 때 for문으로 print문을 하나하나 출력하느라 시간 초과가 났었다.)

val bw = BufferedWriter(OutputStreamWriter(System.out))
사용 방법은 bw.write를 통해 버퍼에 기록하고, bw.flush를 통해 출력.
사용하고 난 뒤에는 bw.close를 꼭 해줘야 한다.
(백준에선 괜찮다지만 습관화합시다.)

그리고 ansList.joinToString(" ")를 사용하면 배열을 for문으로 출력하지 않고 한 번에 원하는 형식대로 출력할 수 있다.





이번 문제에서 실수한 점
1. 입출력 체계정도는 좀 살펴보고 가도 되지 않았을까? 하는 아쉬움.
물론 이번에 처음 써본 거니까, 지금 잘 공부해두면 실전에서는 덜 실수할듯