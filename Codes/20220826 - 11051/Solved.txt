<BarkingDog님의 알고리즘 강의로 풀게 된 문제>
https://www.acmicpc.net/problem/11051

이항 계수. 쉽게 말해 nCr을 구하라는 문제이다.
이 문제에서 주의할 점은 n과 k의 최대 범위가 1000으로 넓기 때문에 조심해야 한다는 점이다.

이 문제 이전에 11050번의 문제를 푸는 게 좋다.
그건 같은 문제인데 n, k의 범위가 최대 10이다.
그 문제의 경우 nCr의 원래 공식인 n!/k!(n-k)!로 답을 내면 된다.

하지만 이 문제는 그런 방식으로는 풀 수가 없다.
좀 대충 말하긴 했지만, 범위가 1000이 되었다는 점은 단순한 문제가 아니기 때문이다.
우선 공식을 제대로 적용할 수 없다. n!은 n이 쪼금만 커져도 끔찍할 정도로 불어나기 때문이다. 예를 들어 n = 12면 n!은 약 4.8억 정도가 나온다. 14정도만 되어도 Int는 감히 담을 수 없는 레벨의 숫자가 된다.
그래서 nCr = nC(n-r)을 통해 구현하는 것도 불가능하다.

그래서 쓸 방법이 nCr을 만드는 공식이다.
혹시 이 피라미드가 기억나는가?
      1
     1 1
    1 2 1
  1  3 3  1
 1 4  6  4 1
1 5 10 10 5 1
이 피라미드는 n = 0부터 n = 5까지 나올 수 있는 모든 nCr의 값을 피라미드처럼 표현한 것이다. 이 피라미드는 여러가지 조합의 성질을 알려주지만, 그 중 가장 중요한 성질은

nCr = (n - 1)C(r - 1) + nC(r - 1)이라고 본다.

이번 문제는 이 공식을 써야 해결할 수 있다.


...근데 이 공식만으로는 해결되지 않는다.
왜냐면 저 공식만 써서는 중복 문제를 해결할 수 없기 때문이다.
조합 문제는 같은 값을 계속 돌려쓰느라 중복 문제가 많이 터지기 때문에, 우리는 이 문제가 DP적인 성질을 어느 정도 가지고 있다는 점도 기억해야 한다.
즉, 조합을 저장하는 배열을 통해 이미 구한 조합은 배열에서 찾아서 바로 리턴할 수 있게 만들어줘야 한다.

암튼 그렇게 공식과 배열을 사용하기만 하면, 생각보다 쉽게 풀린다.




<코드 설명>
메인 코드는 그냥 숫자 둘 입력받아서 factorial 함수를 켜는 게 전부다.

그 외에는 combi라는 1000 x 1000짜리 배열이랑 factorial 함수가 있다.,

combi는 이미 구했던 조합을 저장하고, 바로 리턴할 수 있게 만든 배열이다.

factorial은 생각해보니 factorial이라는 이름이면 안되는 게 맞는데, 사실 이론상 맞으니 상관은 없다.
이 함수는
nCr = (n - 1)C(r - 1) + nC(r - 1)
이 공식을 재귀로 구현하기 위해서 만든 함수이다.

우선 이미 nCr에 해당하는 조합이 있는 경우, 바로 그 값을 리턴하고,
r = 0이거나 n == r인 경우 바로 1을 리턴한다.
이건 위에 있는 피라미드의 양 끝을 보면 알 수 있다. 피라미드에서 1인 부분(양 끝 라인)은 다 r = 0이거나 n == r인 경우이기 때문이다.
위 두 조건에 다 걸리지 않았다면, 그 때는 정말로 nCr을 구현해야 하는 상황이 된 것이므로 (n - 1)C(r - 1) + nC(r - 1)을 구해주면 된다. 나는 이 공식을 combi[n][r]에 저장한 다음 해당 값을 리턴해줬다.

어...놀랍게도 이것만 하면 구현이 끝난다.
