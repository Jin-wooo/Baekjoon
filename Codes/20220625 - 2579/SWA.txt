<Barking님의 알고리즘 강의로 풀게 된 문제>

21년 2학기에 들었던 알고리즘 과목에서 했던 기말 문제풀이 과제에
12조가 2156번 - '포도주 시식'이라는 문제를 가져왔었다.
DP에 정확히 들어맞는? 그런 문제였던 걸로 기억하는데
우리가 이번에 풀었던 2579번 문제와 거의 비슷하다.
\
거기서 말했던 조건은 이번 계단타기랑 거의 비슷하게 1칸, 2칸씩 건너 마실 수 있지만, 3번 연속으로는 마실 수 없다는 조건이 붙어있다.
마지막을 반드시 밟는지 아닌지만 다른듯? 포도주의 경우 마지막 잔을 반드시 마셔야 한다는 조건은 없었다. 이 조건이 포도주 시식과 계단 오르기의 차이를 나타낸다고 생각한다.


우선은 포도주 시식에서 봤었던 방법을 사용해보고 싶었다.
이 문제는 한 번 훑어봤음에도 기말고사에서 틀린 문제라 더 그랬던 것 같다.
그 때는 원리고 뭐고 아무것도 모르고 무지성으로 풀었었는데...
이제는 원리를 차분히 보고 이해한 다음, 이 문제에 적용해보았다.

우선 포도주 시식을 풀던 것처럼 3가지 식을 세워보았다.
  ? ? X - 이전에는 어떻게 골랐는지 모르겠지만 이번에는 안골랐음.
  ? X O - 2칸 전은 모르고, 한 칸 전은 안고른 상태에서 이번 칸을 고름.  
? X O O - 3칸 전 모름, 2칸 전 안고른 상태로 2칸 연속으로 고름.

이렇게 해서 풀어봤는데....실패.



그래서 뭐가 문제인지 고민을 좀 하다가 barking님의 풀이과정을 잠깐 살펴보았다.

barking님의 풀이는 이렇다.
baaaarking님은 점화식을 세울 때 D[i][j]라는 2차원 배열을 만들고
j개의 계단을 연속해서 밟고 i번째 계단을 올랐을 때의 최댓값으로 지정하고,
이 때 i번째 계단은 반드시 밟는 것을 조건으로 달았었다.
(이 경우 j는 반드시 1, 2를 값으로 가지게 된다.)
이래야 마지막 계단을 반드시 밟는다는 조건이 얼추 세워지니까. 

여기까지 보고 깨달았다.
내 풀이는 마지막을 반드시 밟는다는 조건이 안지켜질 수도 있겠구나.
그래서 ? ? X - 이 경우를 없애버렸다.
그러면 i번째 계단을 반드시 밟게 되니까.
이렇게 해놓고 계산한 부분이 바로

	for (k in 3 until listStairs.size) {
            listValue.add(max(
                listStairs[k] + listValue[k - 2],
                listStairs[k] + listStairs[k - 1] + listValue[k - 3]))
        }
이 부분이다.
  위쪽의 식이   ? X O 를 나타내고
아래쪽의 식이 ? X O O 를 나타낸다.
두 값중 더 큰 값을 k번째 계단에 기록해두면서 점차 올라가는 방식.


암튼...풀었다.
근데 답지를 2개나 보고도 쩔쩔맸다는 사실이 좀 그렇다.
그래서 이 문제는 다시 풀어봐야 할 것 같다.
