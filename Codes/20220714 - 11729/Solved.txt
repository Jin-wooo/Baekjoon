<Barking님의 알고리즘 강의로 풀게 된 문제>
https://www.acmicpc.net/problem/11729

이걸 푸는데 5트를 한 흑두루미가 있다? 뿌슝빠슝 ㅋㅋㅋㅋㅋㅋㅋㅋㅋ

문제는 그냥 단순한 하노이 탑 문제다.
다만 순서를 하나하나 출력해줘야 하는 문제다.

문제 자체를 푸는 원리는 이전에 배운 적이 있어서 알고있었다.
하노이의 탑은 재귀로 풀 수 있는 가장 대표적인 문제이고,
그 방법은...
원판이 n개가 있다고 가정하면

n개를 이동하는 최소 횟수 = 
(1 ~ n - 1개를 출발 지점 -> 중간 지점으로 이동)
+ (n번째를 출발 지점에서 도착 지점으로 이동)
+ (1 ~ n - 1개를 중간 지점에서 도착 지점으로 이동)
 => 이동 횟수는 총 2^n - 1

이상의 공식이 나오게 되고, 이후론 n - 1도 계속 이런 식으로 반복하게 된다.
n의 경우 출발:1, 중간:2, 도착:3이 되었지만, 이는 n-1부터는 바뀌게 된다.

...여기까지가 내가 알고 있던 부분이고, 나는 딱 이대로 코드를 작성했으나,
이미 알다시피 나는 4실패 1성공을 했다.


어쩌다가 그랬냐 하면...
1. 시간 초과가 났었다.
cin은 고속화 처리를 했는데 cout에는 그걸 안해서 처리해줬다.

2. 또 시간초과
아, endl을 무의식적으로 적었던 것을 확인했다.
이걸 웨 까먹었을까? 하고 다시 고쳤다.

3. 틀렸다.
시간 문제는 해결했으나, 틀려버렸다.
코드를 잘 보니 내가 2n + 1이라는 괴상한 소리를 써놨다는 것을 깨달았다.
아마 
(1 ~ n - 1개를 출발 지점 -> 중간 지점으로 이동) = n
+ (n번째를 출발 지점에서 도착 지점으로 이동) = 1
+ (1 ~ n - 1개를 중간 지점에서 도착 지점으로 이동)= n
해서 2n + 1이라는 괴상한 착각을 한 모양이다.
이 부분도 이쁘게 수정해줬다.

아, 근데 이 부분은 또 pow를 써야만 한다.
사실 자기 자신을 그냥 곱하라고 해도 큰 문제는 없었겠지만,
나는 pow에 대한 '공포증 극복(?)' 같은 느낌으로 pow에 도전해보았다.
결론은, int 변수를 생성할 때 만들면 굳이 부동 소수점이나 꼬이는 문제가 발생하지 않았다.

4. 컴파일 에러
엥? 컴파일 에러가 난다고?
하고 자세히 잘 보니, pow가 math.h 없이 쓰이고 있다는 걸 발견했다.
아, 그 때서야 자세히 보니까 VS에서는 pow가 그냥 사용 가능한 함수인데, 백준에서는 그렇지 않았다는 걸 알게되었다.
이 부분은 좀 위험할 수 있으니, 자세히 기억하든가 해야겠다고 생각하고
math.h를 include해주었다.

5. 성공!



결국 이번 문제도 이론과 코드 자체는 틀린 게 거의 없었는데
되도 않을 이상한 실수를 너무 많이 해서 시간이 소모되었다는 걸 알았다.


이번 문제에서 한 실수
1. 아 ㅋㅋ 아는 문제잖아! 얼른 풀어야지!
같은 마인드로 임했다가 4실패 1성공같은 괴상한 결과물이 나왔다.
신중하게, 실수하지 말고 풀어보자.
더 자세한 부분은 윗부분 참조.