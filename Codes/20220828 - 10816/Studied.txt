<BarkingDog님의 알고리즘 강의로 풀게 된 문제>
https://www.acmicpc.net/problem/10816

내가 조금만 더 깊게, 잘 생각했으면 풀었을 것 같은데...
머리가 잘 안돌아가서 거의 원리를 보다시피 했다. 여러모로 아쉬운 문제.

이진탐색을 쓰면 범위도 어떻게든 캐치할 수 있을 거라 생각했지만,
어떻게 하면 그 알고리즘을 구현할 수 있을지 제대로 몰랐다고 생각한다.


문제는 크기가 N인 배열과 M개의 숫자를 주는데, 여기서 우리는 각 수가 적힌 카드가 주어진 배열에 몇 개나 들어있는지 출력해야 한다.

배열의 사이즈 범위도 제법 넓고, 찾아야 할 대상도 많기 때문에 이진 탐색으로 호다닥 찾아버리는 게 제일 좋다. 다만 보통의 이진탐색 문제와는 살짝 다른데,해당 숫자의 위치나 존재 여부를 묻는 것과는 다르게 이 문제는 몇 개의 숫자가 존재하는지를 출력해야 하기 때문이다.

barkingDog님이 소개해준 방법은 받은 배열을 정렬한 다음, 찾아야 할 수를 주어진 배열에 삽입할 때 오름차순 순서가 유지되는 가장 왼쪽 위치와 오른쪽 위치를 구하는 것이다. 이렇게 하면 오른쪽 위치에서 왼쪽 위치를 빼는 것으로 그 숫자의 갯수를 구할 수 있기 때문이다. 여기서 삽입이란 보통 언어에서 제공하는 Insert같은 기능을 말한다. 숫자를 인덱스를 지정해서 집어넣으면 그 숫자는 해당 인덱스에 들어가고 나머지 숫자가 밀리는 그런 거.


앞에서 한 말이 이해가 안갈 수 있으므로, 예제를 들겠다.

6 3 2 10 10 10 -10 -10 7 3

위 숫자는 정렬하면 

-10 -10 2 3 3 6 7 10 10 10

다음과 같이 나온다.
이 때 찾을 카드가 3이라면, 우리는 오름차순이 망가지지 않게 3을 넣을 양 끝 위치를 찾으면 된다. 이 경우 왼쪽 끝은 3, 오른쪽 끝은 5가 나온다.
(2에 삽입하면 3 2 3 3같은 형태가 되서 오름차순이 깨지고,
 6에 삽입하면 3 3 6 3 7같은 형태가 되서 오름차순이 깨진다.)


이렇게 양쪽 끝을 찾는 알고리즘을 짜고, 찾아야 하는 모든 카드에 대해 이 두 가지만 찾아서 빼주면, 문제가 풀린다.


그럼 이제 알고리즘을 짤 텐데, 이때 왼쪽이든 오른쪽이든 둘 다 고정적으로 해야 하는 부분이 있다. 이건 숫자 하나를 찾는 게 아니라서 이진 탐색의 조건이 좀 다르게 돌아간다.
1. 삽입을 가정하는 것이므로 right = 오른쪽 끝의 초기값이 배열의 크기를 그대로 쓴다. (1을 빼지 않고 쓴다는 뜻)
사이즈 10짜리 배열이 존재한다면, 인덱스가 10인 곳에도 뭔가를 삽입할 수 있을 것이다. 이 부분이 고려되지 않으면 위의 예제의 경우 제일 큰 10의 오른쪽 값이 정상적으로 나오지 않게 된다.

2. while문의 종료 조건이 left <= right가 아니라 left < right이다.
이는 삽입한다는 것을 가정하고 있는 이 알고리즘의 특성이다. 
원래 이진 탐색의 경우 right = left가 될 때까지 해당 값을 뒤져봐야 하고, 그래도 안 나오는 경우 left > right가 되면 그 값이 없다는 걸 알게 되는데, 이 알고리즘의 경우 left = right가 되는 지점이 우리가 원하던 삽입 지점이므로 이 부분에서 추가로 알고리즘을 돌릴 필요가 없다.

3. mid가 가리키는 값보다 대상이 더 크면 right를 옮길 텐데, 이 때 right의 값은 mid - 1이 아니라 mid가 된다.
이 부분도 어느 쪽 끝을 찾던 동일하다. left는 mid + 1이여도 right는 mid로 고정된다. 이는 삽입한다는 알고리즘의 특성상 그렇게 된다.
예를 들어 

-10 -10 2 3 3 6 7 10 10 10
이 예제에 3을 넣는다고 한다면, 3이 들어갈 가장 왼쪽 위치는 3, 즉 3이 최초로 등장하는 위치지만, 8을 넣는다고 하면 7, 즉 8보다 더 큰 수가 최초로 등장하는 위치이다. 그래서 list[mid] > target이라는 정보만을 가지고 있다면, 이 list[mid]값은 target이 들어갈 수 있는 가장 왼쪽 위치가 될 수도 있다. 그래서 이 부분을 mid - 1을 통해 범위에서 제외해버리면, 정상적인 답이 나오지 않게 되는 것이다.


그리고 다른 점은 딱 하나 있는데, 바로 list[mid] = target일 때다.
왼쪽 끝을 구할 때는 왼쪽으로 최대한 이동해야 해서 right가 mid로 조정된다.
그리고 오른쪽 끝의 경우 오른쪽으로 최대한 이동해야 하니 left = mid - 1로 조정된다.

이 부분만 잘 기억하면 알고리즘을 짤 수 있을 것이다.




P.S. 
참로고 이 문제는 이진 탐색 외의 방법으로도 풀 수 있다. 바로 key와 value를 가진 구조체이다. 이런 구조체를 사용한다면 그냥 쭉 선형으로 탐색한 다음, 해당 숫자를 반환해달라고만 하면 된다. 문제에서 이진 탐색을 사용하면 시간 복잡도가 O(M log N) 정도로 나올 텐데, 아마 구조체로도 비스무리하게 나올 것 같다. 내가 알기로는 map같은 그런 구조체들은 탐색시간이 O(1)이라서 사실상 선형탐색 이상으로 복잡도가 올라가지는 않을 거라 생각한다.




<코드 설명>
위에는 왼쪽 끝의 삽입 지점 인덱스를 반환하는 getStartPoint.
좀 내려가면 오른쪽 끝의 삽입 지점 인덱스를 반환하는 getEndPoint가 있다.
이 함수들의 원리는 위에 잘 적어뒀다. 이 때 반환을 둘 다 left로 하는데, 사실 right든 left든 큰 의미는 없다. while문의 종료 조건상 둘이 같아지면 while문은 튕기기 때문이다.

get시리즈 두 개만 짜면 나머지는 쉽다. 입력값을 잘 받아서 배열을 정렬하고,
값이 올 때마다 왼쪽과 오른쪽 끝을 구해서 빼 주고, 그걸 출력하면 끝. 딱히 고민할 필요 없이 그냥 end - start만 해 줘도 알아서 잘 나온다. (내가 이걸 후처리했었다가 인덱스 범위 초과 에러가 났었다. 전혀 필요없는 연산이였는데...)




<예제>
내가 썼던 건데, 사실 내가 내 방식대로 짠 코드가 아니라서 이 정도의 테스트로도 충분했다고 생각한다.
10
6 3 2 10 10 10 -10 -10 7 3
9
10 9 -5 2 3 4 5 -10 25

ans : 3 0 0 1 2 0 0 2 0 