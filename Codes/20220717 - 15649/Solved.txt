<Barking님의 알고리즘 강의로 풀게 된 문제>
https://www.acmicpc.net/problem/15649

백준에 12개 있는 N&M 시리즈 중에서 1번째 문제.
아마 첫 문제니까 제일 쉬운 문제이지 않을까 싶다.

이번에도 생각보다 빨리, 머릿속에 세웠던 논리들을 잘 풀어낸 것 같다.
다만 너무 졸리고 허리가 아파서 집중하지 못했다.
거기에 이론 자체는 머릿속에 잘 정립했는데, 너무 복잡하게 세워놔서 그걸 제대로 실현하는 게 쉽지 않았던 것 같다.


문제는 단순하다.
1~N까지의 자연수 중에서 중복없이 M개를 골라서 수열을 만들어 출력하는 것.
4 2의 경우 아래와 같은 경우의 수가 나온다.
1 2
1 3
1 4
2 1
2 3
2 4
3 1
3 2
3 4
4 1
4 2
4 3

이전의 숫자도 쓸 수 있다는 거. 1 2와 2 1을 다르게 보는 유형의 문제다.
그렇다는 말은, 언젠가 저 둘을 같다고 보는 문제도 있겠네.


그래서 어떻게 해결했는가 하면...
이번에도 재귀함수를 사용해서 풀었다.


암튼 함수를 보자면...
우선 이 문제를 풀기 위해서 전역 변수를 등록해뒀었다.
수열을 쌓아두기 위한 listy,
해당 숫자가 수열에 쓰였는지를 판단하는 chkList. 이 두 가지이다.
이 둘을 전역변수로 등록한 이유는, 진행상황의 공유를 위해서이다.
이번 문제는 재귀함수로 짰기 때문에, 이 둘이 전역으로 존재하지 않으면...
현재 어디까지 수열을 완성했는지, 지금 시점에서 어느 숫자를 사용했는지를 매번 함수 인자를 통해 전달해주어야 하는 문제가 생긴다.
재귀 함수인데 호출할 때마다 매번 배열 2개를 전달해줘야 한다니...
그거만큼 끔찍한 일을 겪을 바에야 그냥 전역 변수 좀 쓰고 말지.

함수에서 base condition은 idx = m - 1이다. 
여기서 idx는 수열의 idx를 의미한다. 
그러니까 맨 처음에는 idx = 0이 되겠지. 

그리고 m은 M이다. 수열의 총 길이.
즉, idx가 m - 1까지 왔다는 건 listy의 마지막 칸을 제외하고는 전부 채웠다는 뜻이 된다.
여기에 도착하면 chkList에 대해 for문을 돌려서 지금 시점에서 비어있는, 쓰지 않은 숫자들을 찾고, 모였던 수열에 그 숫자를 추가해서 출력해준다.

idx = m으로 만드는 방법도 있었을 것이다.
이러면 더이상은 수열을 채울 수 없어지므로 그대로 for문을 돌려 출력하게 될 것이다. 이렇게 푸는 것이 나쁜 것도 아니고, 아마 구조 자체는 간결해질지도 모르겠지만, 나는 재귀함수를 그만큼 호출하는 것보다 마지막 자리에 남은 숫자들을 하나하나 순서대로 넣어서 출력하는 방식을 골랐다.
재귀를 그만큼 호출하는 것보단 for문 한방으로 퉁치는 게 더 빠르지 않을까? 


idx != m - 1인 경우, chkList에 대해 for문을 돌려준다. 아직 쓰지 않은 숫자를 발견하면 listy의 idx 자리에 그 위치의 숫자를 추가해주고(코드 상에서는 1부터 시작하는 숫자를 사용했음. 그래야 나중에 출력하기 편하니까), 그 위치의 숫자를 사용했다는 표시를 chkList에 남긴다. 그리고 Liner를 재귀 호출하는데, 이 때 idx에는 1을 더해서 다음 인덱스에 대해서 작업해야 한다는 것을 알린다.



보다보면 상태를 공유하는 두 배열들이 전역 변수라서 상태값들이 꼬이는 거 아닐까 하는 생각이 들지도 모르겠다. 꼬이지 않는 이유는 재귀함수가 일종의 Stack처럼 작동해서 그렇다. 잘 생각해보면 반드시 이 함수는 인덱스가 순서대로 작동하게 된다. 그렇게 만들어뒀으니까. 인덱스가 작아졌다 커지거나 하는 일은 없다는 뜻이다. 그런 일이 있으면 이 문제를 성공하지 못했겠지.


barking님의 코드와 설명을 문제를 푼 이후에 살펴보니, 나와 코드가 거의 같다. idx = m - 1부분만 다르네. 이 부분은 뭐... 내 취향대로 만든거니 그럴 수 있다고 본다. 
암튼 나는 무의식적으로 백트래킹을 구현한 모양이다. 생각해보니 백트래킹스럽게 구현한거라서 전역 변수들이 꼬이지 않는 모양이다.

