<BarkingDog님의 알고리즘 강의로 풀게 된 문제>
https://www.acmicpc.net/problem/15683

1182를 풀고 의욕이 좀 죽은 상태에서 시작하게 된 문제.


이번 차시는 시뮬레이션 차시였다.
시뮬레이션이 뭔가 했더니 문제를 해결하는 알고리즘이 딱히 존재하지 않는 경우를 말하는 것 같다. 쉽게 말해 빡구현.

근데 나는 오히려 이 시뮬레이션이라는 표현 덕인지, 내가 직접 겪지 않으면 뭘 이해하지 못하는 특유의 성격 때문인지는 몰라도, 고생을 많이 했다. 정확히는 내가 이 말이 뭔소린지 몰라서 대충 알아듣고, 그냥 그러려니 했었던 것 같다. 설마 저정도로 힘든 거겠어. 원리가 조금은 있겠지...정도로만 생각했었다.

그래서인지 푸는 데 거의 이틀을 쓴 거 같다. 19일 밤에 시작해서 21일 밤 즈음에 다 풀었으니까. 해결에 시간이 오래 걸린 이유는 문제 자체가 좀 복잡한 것도 있었지만, 좀 더 효율적으로 풀 수는 없을까 하고 고민을 너무 오래 했었던 것 같다. 처음에 CCTV의 제한 수를 보지 않아서 단순하게 그냥 들이박아서는 뭔가 해결될 각이 안보였던 것도 있었고...(CCTV가 최대 8대니까 6.5만에서 끝난거지, 15개 정도만 되어도 경우의 수가 10억이 넘어간다.)


암튼 이 문제는 그냥 악으로 깡으로 경우의 수를 전부 다 돌려보는 게 핵심이었다. 케이스를 분리하거나 효율적으로 돌리면 안 되는 문제. 단순하지만, 늘 효율적이고 빠른 길만을 찾아야 했던 이전까지의 문제와는 다른 느낌이라 나는 오히려 이쪽을 더 못 푸는 것 같다.

애초에 집중력이 떨어졌던 부분도 어떻게 해야 효율적으로 탐색할 수 있을지 고민하다가 그랬었다. 5를 미리 그려버리는 아이디어는 좋았지만, 그 이후에 나온 아이디어들은 다 정말이지 별로였다. 예를 들면 지금 당장 얻을 수 있는 가장 큰 값을 골라 조합한다는 아이디어부터 4부터 순서대로 내려가면 좀 더 쉽게 답이 나오지 않을까...하는 아이디어까지. 잘 생각해보면 죄다 논파될 수 있는 아이디어였다.






함수를 설명하기 앞서, 이 문제를 풀기 위해서 만들어야 하는 부분은
1. CCTV가 감시하는 영역을 표시하는 부분
2. 그 표시를 다시 되돌릴 수 있는 부분
3. 위 작업을 반복해서 작업할 수 있는 부분

브루트 포스로 돌려야 한다는 걸 깨달아도 생각보다 거쳐야 할 난관들이 많았다. 특히 2번. 매번 CCTV의 사각지대를 찾아내고 난 다음 지도를 초기화시킬 방법이 어중간했다. barkingdog님은 지도를 복사하는 걸로 해결했는데, 나는 그 방법을 실패해서(깡으로 복사하다가 막힘), 그걸 더 찾아보지 않고 다른 좋은 방법을 찾기 위해 그만뒀다.


이제 내가 만든 함수를 설명해볼까 한다.
코드의 전역 변수들은 가로세로를 의미하는 N, M과 맨 처음에 0으로 표시된 부분=CCTV 사각지대의 총 합인 numArea, 사무실을 나타내는 office, 지도를 복구하기 위해 만든 recoverQ가 있다. 뒤의 둘은 updater라는 함수가 참조해야 해서 전역변수로 두었다.

코드를 보면 가장 위에 updater 함수가 있는데, 해당 방향을 쭉 탐색하면서 CCTV가 보는 영역을 8로 표시하고, 6을 만나면 나와버린다. 그리고 이 함수는 int고, 지금까지 8로 표시한 값을 리턴한다. 이 리턴값을 쓰는 부분은 추후 설명할 예정이다.

그리고 메인 함수. 메인 함수에서 눈여겨볼만한 변수는 limdiv, tmpArea, vecCCTV, vecFive정도겠다. limdiv는 이후에 말할 4진법 나누기 방식을 쓸 때 사용할 변수고, tmpArea는 numArea를 복사해온 다음 사용하는 변수이다. 또한 vec 시리즈들은 CCTV의 위치를 받는 벡터이다. 다만 전자는 1~4까지, 5는 5번 CCTV만을 입력으로 받는데, 이는 5번은 4진법으로 굴릴 필요 없이 그냥 처음부터 맵을 다 채우고 생각해도 무방해서 이렇게 작업했다.

이후로는 메인에선 입력을 받은 다음, 맵을 만든다. 이 때 0이면 numArea에 값을 1 더하고, 6이 아니라면(1~5) 각자에게 맞는 벡터에 들어간다.

다음으론 vecFive 안에 있는 CCTV의 감시 영역을 전부 표시해준다.
그리고 여기서 보면 numArea -= updater()가 나오는데,
updater가 리턴한 "8로 표시한 값" = "CCTV 감시 영역"을 numArea에서 빼 주는 것이다. 이렇게 하면 추가로 이중 for문을 돌면서 매번 맵을 검사하지 않아도 빠르게 사각 지대의 수를 알 수 있다.

이 다음에 쓰잘데기없이 while로 recoverQ에 있는 값들을 전부 빼버리는데, 이걸 안 빼주면 5번 CCTV의 표시 영역을 다 지워버린다. 5번 CCTV를 표시할 때만 어떻게 좀 빼주면 좋을텐데, 머리가 안 돌아가서 그냥 이대로 냅둬버렸다. 더 좋은 코드가 있으면 좋았을 텐데. 심지어 이거 풀자마자 누가 봐버려서 좀 쪽팔렸다.



다음으로는 forcelim이라는 변수가 나온다. 이는 4진법 방식으로 계산할 때 최대 한계치를 의미하는 변수이다.
자꾸 4진법 이야기를 하는데, 이건 모든 부분을 반복해서 돌려야 하고, 그 중에서도 각 CCTV의 방향을 최대 4방향까지 돌려봐야 하는 현 시점에서 유용하게 쓰일 수 있는 방법이다. 이렇게만 들어서 이해가 안된다면 그냥 4진법 숫자들을 보면 잘 알 수 있다.

예를 들어 CCTV가 4개 있고, 0 1 2 3이 각각 북 동 남 서를 가리킨다고 치면,
0  = 0(4)   = 0000 = 모든 CCTV가 북쪽을 바라보고 있음
1  = 1(4)   = 0001 = 0번 CCTV는 동쪽, 나머지는 북쪽을 바라보고 있음
52 = 310(4) = 0310 = 0번과 3번은 북, 1번은 동, 2번은 서쪽을 보고 있음.
이렇게 흘러간다. 즉, for문을 통해 숫자를 올린 다음, 4진법으로 계산해주기만 하면 된다는 뜻이다.

근데 이렇게 되면 두 가지 문제가 생긴다.
하나는 사람이 눈으로 보기에는 0310이 그렇게 보일 수 있다지만, 실제로 프로그래밍은 저렇게 직관적으로 볼 수 없으니 다른 방법을 생각해줘야 한다는 거고, 하나는 저렇게 늘리는 숫자의 최대치를 정해줘야 한다는 것이다.

전자의 경우, 해결책은 10진법에 있다.
예를 들어 3461이라는 숫자가 있다면, 여기서 어떻게 1이라는 숫자를 추출할 수 있을까? 정답은 10으로 나눈 나머지를 얻는 것이다.
그럼 6을 추출하기 위해서는 어떻게 해야 할까? 답은 10으로 나눈 다음 346이 되면 그 숫자를 10으로 나눈 나머지를 얻는 것이다.

익숙한 방식인데, 이 방식을 4진수로 적용하면 된다. 즉, 4로 나누고, 4로 나눈 나머지를 가져오는 걸 반복하면 위처럼 작업할 수 있게 된다.

그리고 후자의 경우, 최대치가 바로 forcelim의 공식이다. 
4의 (CCTV 갯수) 승. 엄밀히 말하자면 저 숫자에 1을 뺀 숫자까지 해야 하는데, 그건 for문에서 미만으로 처리하기 때문에 상관없다.


이제 이 forcelim만큼 for문 loop를 시작한다. 여기서 반복자로 쓰이는 f가 몇 번 반복하는지를 알려주는 기준이 된다. 근데 원본 f를 훼손하면 꼬이니까 limdiv에 저장하는 거고. 같은 이유로 numArea도 tmpArea에 저장한다.

그리고 나온 4진수에 맞게 CCTV의 방향을 정하고 updater로 탐색을 하고, 탐색이 다 끝난 이후에는 지금 나온 tmpArea가 가장 작은 사각지대의 갯수를 저장하고 있는 ans와 비교해서 어떤지 확인하고 값을 대입할지를 정한다.

마지막으로 보이는 while문이 바로 office 변수 초기화를 위한 부분이다. 미리 updater에서 좌표를 체크할 때 해당 좌표를 queue에 넣어두고, 여기서 하나하나 꺼내면서 나온 좌표를 다시 0으로 바꾸는 것. 이 방법으로 하느라 5 부분을 그렇게 이상하게 작업하게 된 것이다. 근데 5를 매번 방향 바꾸면서 작업하는거보다는 이렇게 하는 편이 더 나아보였다.






이번 문제에서 한 실수
1. 효율적으로 풀어도 답이 안나올거같으면 무식하게라도 풀 생각을 좀 해봐야겠다. 이것도 경험치 차이라는 생각이 든다.

2. 문제 똑바로 읽기. 문제 똑바로 이해하기. 그리고 견적 대충 내보기.