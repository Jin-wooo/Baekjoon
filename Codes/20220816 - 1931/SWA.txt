<BarkingDog님의 알고리즘 강의로 풀게 된 문제>
https://www.acmicpc.net/problem/1931

이전에 그리디 알고리즘을 배웠을 때도 나왔었던, 이 분야 단골 문제.
주어진 회의실의 사용 시간을 보고 회의가 겹치지 않게 하면서 회의실을 쓸 수 있는 최대 시간을 출력하는 단순한 문제이다. 

이번 문제는 하다보니 SWA가 되었다. 문제를 풀다가 그리디가 너무 이해가 안가서 원리를 제대로 파악하고 푸느라 그랬다. 거의 보고 풀다시피한건 맞으니까.

이렇게 된 이유는 barkingdog님의 강의에서 이 문제를 O(N^2)로 푸는 방법을 설명할 때 전체적으로 정렬해서 보는 방법이 있다는 말을 듣고 부라나케 정렬하고 문제를 시작한 내 잘못이 제일 크다고 본다.

시작시간 - 끝시간으로 정렬해버린 다음에 문제를 풀려고 하면 O(N^2) 외에는 풀 수 있는 방법이 없게 보인다. 이래서 나는 내가 원리파악도 제대로 못한 바보인줄 알았다. 그래서 barkingDog님의 강의를 좀 더 읽게 되었고, 전체 정렬하는 방법을 소개한 이유가 쓰지 말라는 의미였다는 것을 알게 되었다. 왜냐면 이 방법은 O(N^2)인데, N이 10만이니까 저 방법은 100억번정도는 연산해야 하는 기법이 된다. 역시 사람 말은 끝까지 들어야 하나보다.

그래서 정렬을 확 지워버리고 예제를 다시 차근차근 보았다.
예제에서는 끝 시간이 정렬된 채로 나와 있었고, 자세히 보니 끝 시간이 정렬된 상태라면 그걸 기준으로 "선택된 회의 시간의 끝시간과 겹치지 않는 가장 가까운 회의 시간"을 고르기만 하면 된다는 것을 어렴풋이 알게 되었다. 여기서 가장 가까이라는 말은 회의 끝 시간이 나보다 조금 먼 회의 시간을 의미한다.

다른 부분을 전혀 살펴보지 않고 이렇게만 골라도 되는 이유는,
내 끝 시간과 가장 가깝지 않지만 겹치지는 않는 회의 시간을 고르면 가장 가까운 회의 시간의 끝시간보다 멀리 있어서 훨씬 길거나 효율적이지 못한 것이 확정적이기 때문이다.
말이 좀 이상하니까 그냥 예시를 들까 한다.

11
1 4
3 5
0 6
5 7
3 8
5 9
6 10
8 11
8 12
2 13
12 14

이건 해당 문제의 예제이다.
내가 가장 가까운 1 4를 골랐다고 가정하면
내가 풀었던 방식에 따르면 4 이상의 시간을 시작 시간으로 가지는 값 중에서 가장 가까운 값을 골라야 한다. 그런 값은 5 7이 있을 수 있겠다. 하지만 가장 가깝지 않고 겹치지 않는 회의시간을 고르면 5 9나 6 10정도가 골라질 수 있다. 이 때 5 9를 고르면 원래 5 7보다 훨씬 길어서 그 다음에 고를 수 있는 회의 시간이 12 14정도밖에 안 생긴다.

혹시 저 예제에 4 7이 있었다면, 그건 그거대로 4 7을 고르는 편이 낫다. 5 7을 고르든 4 7을 고르든 정답에 변화가 생기는 것은 아니지만, 알고리즘대로라면 그게 맞으니까.


암튼 이런 식으로...주어진 회의 시간들이 끝 시간으로 정렬되어 있다는 가정 하에 가장 가까이 있는, 겹치지 않는 회의 시간대를 고르기만 하면 된다.
이걸 강조하는 이유는, 내가 이 부분에서 틀렸기 때문이다.
이는 아래쪽의 제출 부분에서 말하겠다.



<코드 설명>
애초에 문제를 해결하는 방법 자체가 간단해서인지 알고리즘도 단순하게 나온다. 

다른 부분들은 대충 다 알텐데, scheduleArray의 경우 회의의 시작 시간과 끝 시간을 같이 담을 수 있도록 Pair로 선언해줬다.


암튼 이후 배열을 정렬하는데, 반드시 second를 기준으로 정렬한 다음 first를 기준으로 정렬해줘야 한다. kotlin으로 푸는 경우 sortBy로는 정렬이 안 되서 sortWith를 통해 두 가지 정렬 기준을 마련해주는 게 좋다.

마지막으로 할 일은 끝 시간을 기록할 변수를 만들고, 이걸 0으로 설정한 다음 for문을 통해 가장 가깝고 겹치지 않는 회의 시간을 계속 가져오는 것이다. 한 번 가져오면 그 회의 시간의 second = 끝 시간을 다시 변수에 저장하고 또 그 시간을 다음 시작 시간과 비교하고... 그냥 그렇게 쭉 가져오면 된다. 그러면 for문 딱 하나로, O(N)으로 문제가 해결된다.



<주의사항>
이번 문제처럼 2개씩만 입력받는 문제는 입력받기가 좀 애매하다. 나는 보통 List로 임시 변수를 선언한 다음 readLine().split(" ").map { it.toInt() }를 통해 받아오곤 하는데, 이걸 Pair로 받는 방법을 좀 알아내야 할 것 같다.




<제출>
어...근데 이번 문제는 2번 실패했다.

왜 실패했는가 하면, 전반적으로 정렬 문제 때문이다.
나는 정렬해주는 줄 알았지...
그래서 그냥 넣었던 건데, 정렬해준다는 말이 없단 걸 깨닫고 뒤늦게 정렬해줬다.

그런데 또 틀려서 보니까, sortBy로 second를 기준으로 정렬했기 때문에 first는 고려대상이 아니어서 틀린 거였다. 이전에 테스트할 겸 first로 정렬했을 때는 분명 잘 돌아갔었는데...

그래서 sortWith를 통해 second와 first를 둘 다 정렬기준에 포함시켜서 정렬하니 바로 성공했다. 

혹시 이 부분이 잘 되었는지 궁금한 사람들은
5
6 7
6 6
5 6
5 5
7 7
이 예시를 참고하면 좋다.



<이번에 실수한 부분>
1. 문제가 명시하지 않은 부분을 명시했다고 착각해서 제출에 실수가 있었다.
다음에는 좀 더 문제를 잘 봐야겠다.




Example
12
1 4
3 5
0 6
6 10
5 9
5 7
8 11
8 12
3 8
2 13
12 14
4 7