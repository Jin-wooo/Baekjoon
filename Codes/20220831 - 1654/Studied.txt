<BarkingDog님의 알고리즘 강의로 풀게 된 문제>
https://www.acmicpc.net/problem/1654

이번 문제는 정말 자신있었는데...
아직 parametric search는 더 공부가 필요하다고 느껴진다.
암튼 이번 문제도 풀다가 도저히 답이 안나와서 Studied로 맞췄다.

Parametric search. 지난번 그리디때 1477번을 풀면서 처음 접해본 개념이었다.
결정 문제로 바꾸는 거라는데, 이제는 관련된 내용을 많이 봐서 이게 무슨 소린지는 대충 감이 오는 것 같다. 결국 Parametric search의 목적은 "조건을 만족하는 최솟값이나 최댓값을 구하는 문제를 결정 문제로 변환해서 탐색을 수행하는 것"이라고 할 수 있겠다. 좀 더 풀어서 말하자면, 최소/최댓값을 결정하는 문제를 값을 결정하는 문제로 바꾼 다음, 그 값에 대한 탐색을 수행하는 것이라고 할 수 있겠다. 이 때 사용하는 방법이 이분 탐색인거고.
문제를 풀다 보면, 이 부류의 문제들을 풀기 위해서는 어느 정도 주객전도같은 입장으로 문제를 봐야 한다는 생각이 든다.  




<코드 설명>
핵심은 Parametric search를 위해 이진 탐색을 살짝 수정해주는 것이다.
알고리즘다운 부분은 딱 그정도이다.

나머지는 전부 입력이니까, right변수부터 설명하겠다.
right변수가 지금 보면 lines라는 array의 최댓값을 Long으로 변환해서 가져오는데, 사실 이 부분은 그냥 Int의 최댓값으로 줘도 된다. 왜냐면 Int의 최댓값이여도 이진탐색이라 최대 시간복잡도가 O(31)밖에 안 된다. 저걸 최댓값으로 줘 봐야 연산 한두번? 정도가 줄어들 뿐이다.

이후에는 이진 탐색을 위한 while문이 있다. 
이진 탐색과 형태가 크게 달라지지는 않는다. 다만 while문의 조건이 지난번에 풀었던 10816번 문제처럼 left < right이다. 또한 이진탐색에서 범위를 좁히는 주체가 랜선의 갯수를 저정하는 cnt변수와 목표 랜선 갯수인 targetLim이다. mid값 ---- 1 을 기준으로 랜선을 잘랐을 때 나온 랜선의 갯수와 targetLim을 비교해서 이진 탐색의 범위 ---- 2 를 좁힌다고 생각하면 된다. 

그렇게 좁힌 다음, right나 left 둘 중 하나를 출력하면 된다. ---- 3


<주의사항>
1. mid의 연산 방식이 원래 이진 탐색과는 좀 다르다.
기존의 (left + right) / 2가 아니라 (left + right + 1) / 2로 연산한다.
이는 후술할 left와 right를 이동시키는 부분과 관련있다. mid가 이런 식으로 계산되지 않으면 left와 right가 절대로 서로 만나지 않게 되면서 무한 루프에 빠진다. 2. - 2) 참조.


2. 변형된 이진 탐색이라고 해야 할지, 암튼 left와 right가 원래대로 mid + 1이나 mid - 1을 쓰지 않고 mid만 쓰는 경우가 있다. 이렇게 mid로 만들어야 하는 경우를 판정하는 것도 쉽지는 않은데, 이걸 판단해서 구현해도 정말 한 끗 차이로 무한루프에 빠지거나 답이 엉뚱하게 나오는 경우가 있다. 이럴 때 어떤 값이 mid로 고정되느냐에 따라 신경써줘야 하는 부분이 조금씩 달라진다.

공통적으로 신경써줘야 하는 부분은 while문의 조건이 left < right라는 것이다. parametric search처럼 찾아야 하는 숫자가 정확히 존재하지 않는 경우, 답은 left = right가 되는 숫자로 내게 되는데, 이걸 구현하려면 조건이 저렇게 변해야 한다. 같아지면 연산을 추가로 더 해서 값이 꼬여버린다.

그럼 조건에 맞는 적당한 최댓값을 변수에 저장하면 되는 게 아닌가? 하는 생각을 할 수도 있는데, parametric search의 경우 그 조건을 단 한 번도 건드리지 않고 답이 나와버리는 경우도 있다. 3. 참조.
 
또한 left와 right의 값을 조정하는 조건문(이진탐색에서 범위를 좁히는 주체)에서 조건이 같은 경우를 신경써야 한다. 이번 문제의 경우 랜선의 갯수인 cnt와 targetLim인데, 이 둘이 서로 크거나 작을 때는 left와 right의 값을 조절하면 되지만, 같을 때는 어디로 조절해야 할지 확실하지 않다. 이건 문제를 잘 읽고 같은 경우를 직접 판단해서 알고리즘을 짜야 한다. 그거 말고는 방법이 없다.


	1) right = mid인 경우, 큰 값이 mid의 값을 반드시 포함해야 하는 경우를 말한다. 이런 경우 이번 문제와는 반대로 최솟값을 구하는데 쓰인다. 이 때는 별로 신경쓸 게 없다. 왜 right가 mid - 1이 아닌 mid가 되어야 하는지만 잘 생각하고, 근거가 충분하다면 이걸 적용하면 된다.

	2) left = mid인 경우, 작은 값이 mid를 반드시 포함해야 하는 경우를 말한다. 이게 이번 문제처럼 최댓값을 구할 때 쓰인다. 이 때는 1.처럼 mid의 연산 방식을 바꿔야 한다. 이는 mid를 구하는 원래 공식이 /2를 해주기 때문인데, 이렇게 나눠버리면 나머지는 버려지고, 몫만이 남으면서...우리가 보기에는 왼쪽으로 이동하려고 하는 성질을 띄게 된다. 그래서 기존의 공식을 사용하면 left와 right가 딱 1차이 나는 애들은 무한 루프에 빠지게 된다.




3. parametric search를 위해 개조된 이진 탐색의 경우 right나 left 둘 중 하나의 값을 출력해야 한다. 기존의 이진 탐색과는 달리 while조건문에 =이 빠져있으므로 어차피 같아질때쯤 while이 종료된다.

이걸 풀다보면 몇몇 사람들은 "왜 가장 큰 값을 Max로 넣지 않고 left와 right가 같아질 때까지 기다리고 있는 건가요?" 같은 질문이 떠오를 수도 있다. 사실 이론상으로는 맞을수도 있다. (cnt >= targetLim)에서 max(지금 온 mid, 최댓값)을 하면 앵간한 상황에서는 다 맞는다고 보면 된다. 

그런데 저게 한 번도 켜지지 않는 상황이 온다면?
예를 들어 랜선의 길이가 1이 되어야 하는 상황이 된다면...
3 12
4
4
4
같은 상황을 상상해보자.
이 경우 랜선 길이를 1로 만드는 게 가장 현명할 것이다. 근데 여기서 max를 써서 풀게 되면, max 함수는 단 한번도 켜지지 않고 계속 right의 범위만 줄어들다가 left = right = 1이 되면서 while문을 탈출하게 된다. 이렇게 되면 최댓값을 저장해두는 변수에는 그 어떤 값도 들어오지 않게 되면서 문제가 틀리게 된다.

변형된 이진 탐색이라 left < right인 while문을 쓰는 경우, 거의 대부분 left = right로 끝나게 만들어놓고 left를 출력하는 게 제일 좋다.


<이번 문제에서 실수한 점>
너무 성! 급! 함!

<예제>
3 9
4
3
2
ans : 1
max로 값을 넣어뒀을 때 걸리는 예제. max나 값 비교를 사용했으면 이 값이 0.