나는!
빡대가리다!

나는!
빡빡이다!


이딴 문제에 2일? 아 ㅋㅋ




다들 다이나믹이니 BST니 해서...나는 BTS를 써먹어서 풀었읍니다.
다이나믹이든 BTS든 결국 원리는 거의 비슷한 것 같다.

BST를 풀어둘 때, 어느 칸에서 2나 3이 걸리면
그 즉시 반복문을 깨고 그 계산값을 답으로 낸다. 
왜냐면 계산이 오래 걸리는 놈일수록 값이 더 커질테니까.
최소값이 아니라 모든 값을 싹 다 비교하면 시간이 너무 오래걸려서 못해먹음.
심지어 2랑 3을 스킵해도.

이렇게 가장 가까운 2나 3을 캐치해서(아마 그 값이 가장 작은 값일테니)
그걸 바로 답으로 내는건...언뜻보면 비교도 안하는 멍청한 방법같지만
실제로는 괜춘한 방법이다. 이건 Search Tree의 특성인 것 같은데,
결국 우리는 이 BST를 계산하면 1단계 숫자, 2단계 숫자...이런 식으로 탐색한다.
그러니까 필연적으로 0 11 222 333333333 444444444444444 같은 느낌으로 계산을 하게 된다.
예를 들자면...12를 세 조건대로 값을 도출하면 6(/2) / 4(/3) / 11(-1)이 된다.
이 세 값은 전부 계산을 한 번 한 값이 된다.
그리고 6은 3, 2, 5 | 4는 2, 3(3으로 못나누니까 3은 없음)...뭐 이런식으로 나오는데,
여기서 6이 내뱉은 3이 중요하다.
3을 냈으면 그 다음에는 3으로 나눠서 1이 바로 나오겠지.
그러니까 쟤가 가장 짧은 '1로 만드는 방법'이다.
다른 것은 얘보다 더 긴 방법이거나 어차피 방법이 같아서 굳이 계산할 필요가 없다.
이건 값만 내는거지 방법까지 요구하지는 않았으니까.