<BarkingDog님의 알고리즘 강의로 풀게 된 문제>
https://www.acmicpc.net/problem/11726

2 x n 사이즈의 타일을 채우는 경우의 수를 물어보는 문제이다.
사실 이렇게 듣기만 하면 좀 막막할 수 있다.
나도 DP 파트니까 DP로 푼다는 힌트를 얻은 거지,
아니었으면 한참을 헤맸을 것 같다. 

그림을 그려서 풀었는데
1은 1, 2는 2, 3은 3, 4는 5, 5는 8....
왠지 규칙이 보일듯했지만, 뭔가 확실하질 않아서 이번에도 도움을 받기 위해 barkingdog님의 글을 봤다.
barkingdog님은 우선 맨 앞을 채우는 경우의 수를 생각해보라는 말을 했었다.
그러니까 2 x 1. 세로로 긴 2칸짜리로 맨 앞을 채우는 경우를 의미한다.
그렇게 되면 나머지는 아마 n칸을 기준으로 한다면 n - 1이 되겠지?

어, 그러면 2칸을 채우는 경우의 수는?
1x2를 세로로 두 칸 놓는 것처럼 되지 않을까?
--
-- 이런 식으로?
어, 그러면 이 경우에는 n - 2를 하면 되는건가?
그럼 n의 값은 (n - 1) + (n - 2) 를 하면 해결되는 건가?
그러고 보니 그림도 그렇게 되네?
어? 어?

뭐 이런 식으로...2x1을 둔다는 아아디어 하나 봤더니 나머지는 대충 술술 풀렸다. 거기다가 내가 문제를 풀기 위해 그렸던 그림이 지금 세운 논리에 딱 맞는 순서로 그려져서 이해가 더 빨랐었다.


암튼 이렇게 열심히 풀고 제출을 하니...
처음에는 그냥 제출하자마자 틀렸단 소리가 나왔었다.
엥? 뭐가 문제지? 같은 생각을 하면서 살펴보니,
내가 10007로 나누지 않았다는 것을 알게 되었다.

그래서 답 쪽에만 그걸 적어뒀었는데,
질문 게시판쪽을 잠깐 돌아보니 오버플로우를 신경쓰라는 말이 있었다.
그래서 1000을 해보니까 13억? 정도가 나오길래 괜찮아보여서 그냥 제출하려다가...
생각해보니 1000에서 13억이 최대로 나오는거면 오버플로우라는 말 자체가 말이 안된다 싶어서 500을 입력해보니, -12억이 나오는 것을 보고 알게 되었다. 어디서 어떻게 나든 곳곳에 오버플로우가 나긴 난다는 것을.

그래서 이 부분은 매 연산마다 10007의 나머지를 저장하는 것으로 해결했다.
이렇게 하면 마지막에 10007로 나눠주지 않아도 같은 효과를 얻을 수 있다.


그러고 제출했더니 이번에는 인덱스 에러.
인덱스가 범위를 벗어난 에러였다.

반드시 범위 안으로 넣을 수 있게 
val squareArray = IntArray(vert + 1)로 세웠는데..
뭐가 문제인가 싶어서 질문 게시판 쪽을 조금 더 돌아봤는데
1을 생각해보라는 힌트를 보고 1을 넣어보니 그자리에서 죽었다.
생각해보니 squareArray[2] = 2가 있으면 1에서는 실행이 안될수밖에 없었다.
그래서 이 부분은

    if (vert <= 2) {
        println(vert)
        return
    }

이렇게 고쳐주었다.
vert를 그대로 내는 이유는, 우연히 배열의 첫 번째와 두 번째가 1, 2여서 그렇다.


암튼, 이렇게 해서 제출은 성공.




오늘 실수한 부분
1. 너무 아무생각 없이 질문게시판을 뒤져보는 게 아닐까?
내 힘으로, 내 스스로 원인을 찾아서 해결하는 게 제일 좋을텐데.
다음 문제부터는 앵간해서는 들어가지 말아야 할 것 같다.
내 문제 해결능력을 너무 낮추는 것 같다.

2. 안 풀리니까 힌트를 슬쩍슬쩍 보는 습관을 좀 어떻게...좀... 막고 싶다.