<Barking님의 알고리즘 강의로 풀게 된 문제>

아주 약간의 오해로 이상하게 풀었던 문제.
쪼금만 더 잘 생각했으면 쉽고 빠르게 풀었을 것 같다.



이미 강의를 통해 연결 리스트를 사용하는 게 좋을 거라고 충분히 사전 인지를 듣고 나서 풀게 된 문제임에도 거의 6시간 이상을 사용한 것 같다.

핵심은...
Iterator의 특성을 이용하면 이 문제를 쉽게 풀 수 있다는 것이다.
우선 abcd라는 문자가 이미 입력되어있는 상황을 가정해보자.
  a   b   c   d 문자는 이렇게 입력되어있을텐데...
그럼 '커서'가 있을 수 있는 구간은

| a | b | c | d | (|는 커서를 의미함)
이런 식으로 5군데다.

나는 (멍청하게도) 처음에 인덱싱을 하려면 앞에 추가적인 글자가 필요하다고 생각했다. 그러니까...

0  a  b  c  d
이렇게 해줘야 iterator가 5개를 인식할 수 있다고 생각했다.
괴랄하긴 한데, 그러니까... 

0 | a | b | c | d |
  ↖  ↖  ↖  ↖  ↖
    O   O   O   O   O(list.end())
(O는 알파벳임. iterator가 가리키는 부분을 나타냄.)

이런 식으로 생각하고 있었다는 거지.
근데 이렇게 만들면...아예 안되는 건 아닐텐데, 꼬인다.
왜냐면 iterator들의 end()는 다들 마지막 인덱스 + 1을 가리키니까.

그러니까 저 '이상적인 것처럼 보이는 그림'은 실제로는 ...
0 | a | b | c | d |
  ↖  ↖  ↖  ↖  ↖
O   O   O   O   O   O
이렇게 6개의 공간을 만들고, 이렇게 하다보니 많이 꼬였다.
사실 커서가 들어가야 하는 공간은 (길이) + 1이고,
Iterator도 보통 (길이) + 1의 공간을 돌아다닐 수 있으니까...

| a | b | c | d | 
↖  ↖  ↖  ↖  ↖
  O   O   O   O   O(list.end())
그냥 이렇게 만들어도 괜찮았던 거였다.
이걸 몰랐던 것 같음.

위에서 풀었던 건 싹 날리고 이렇게 새로 풀어보니까 거의 30분? 안쪽으로 다 풀렸다. 