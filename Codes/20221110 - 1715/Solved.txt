<BarkingDog님의 알고리즘 강의로 풀게 된 문제>
https://www.acmicpc.net/problem/1715

사실 강의를 보면서 예제를 풀고 있으니 어느 정도 힌트가 있기도 했고,
궁금해서 설명을 좀 더 읽다가 그리디라는 치명적인 힌트를 얻어버렸다.

근데 그리디라고만 해서는 뭔 소린지 몰라서, 혼자 좀 고민을 했었다.

처음에는 문제를 제대로 이해하지 못한 것 같아서 고민을 좀 오래 했었다.
그리고 둘씩 짝지어버리면 가장 작아지는 게 아닌가 싶어서

6
1
2
3
4
5
6
이 예제를 기준으로

1 2   3 4   5 6
3  7  11
10 11
21
ans = 3 + 7 + 11 + 10 + 21 = 52
그냥 있는대로 합쳐보거나

1 4    2 6    3 5
5      8      8
13            8
21
ans = 5 + 8 + 8 + 13 + 21
되는 대로 막 합쳐보거나

1 6 + 2 5 + 3 4
7 + 7 + 7
14 + 7

ans = 7 + 7 + 7 + 14 + 21
이런 식으로 큰거 + 작은거 조합으로 가보는 등 다양한 조합들을 살펴보았다.


그러다가 작은것부터 합체시키면 값이 조금 줄어들 수 있다는 걸 알게 되었고, 이걸 좀 더 고민해보니 위의 예제처럼 꼭 2개씩 짝지어서 하는 게 아니라 작은 걸 되는대로 계속 뽑아서 합체시키고, 그 값을 뽑을 대상으로 등록해두면 결과적으로 작은 값이 나올 수 있다는 것도 알게 되었다.

1 2 3 4 5 6
3 3 4 5 6
4 5 6 6
6 6 9
9 12
21 
ans = 3 + 6 + 9 + 12 + 21


아, 이래서 그리디하게 가면 되는구나.
아, 작은 걸 뽑아야 하고, 그 값을 계속 넣고 뽑아야 하니...
우선순위 큐를 쓰면 엄청 쉽겠구나.

baaarking님의 그 말을 이해하니 문제가 엄청 쉬워보였고,
반대로 그런 쉬운 내용을 이해하는 게 너무 오래 걸려서 아쉬웠다.

+ 푼 다음 날 생각났는데, 우선순위 큐는 큰 수부터 제거하는 게 아니였다.
나는 우선순위라고 해서 큰 수부터 내보내는 줄 알았는데, 오름차순이였더라.
그래서 이 문제가 맞았었나보다.



<코드 설명>
골드 4레벨인데 이렇게까지 쉬운 문제가 있었던가? 싶다.
아마 실제 레벨은 실버 1정도겠지.

코드의 알고리즘은 while문 포함 5줄이라고 생각하면 된다.
우선 모든 값을 우선순위 큐에 넣는다.
특별히 처리해야 하는 일은 없다. 그냥 넣기만 하면 끗.

이후는 while문에서 처리한다.
우선 숫자를 2개 뽑는다. 이러면 제일 작은 숫자가 2개 나온다.
이 둘을 더하고, ans에 그 값을 더해준 다음,
더했던 값을 다시 우선순위 큐에 넣는다.
이 과정을 숫자가 하나 남을때까지 반복한다.
하나 남으면 숫자가 다 더해진 거라 의미가 없거든.






<이번 문제에서 실수한 점>
실수라고 하긴 뭣한데, 문제를 이해하는 시간이 너무 오래 걸리지 않나? 싶다.
이 문제는 코드를 짜고 테스트하는 데 10분이 채 걸리지 않았는데, 생각에만 12분 가까이 썼었다. 문제들을 반복해서 풀어주면 해결될까?