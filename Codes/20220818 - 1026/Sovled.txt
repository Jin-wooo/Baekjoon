<BarkingDog님의 알고리즘 강의로 풀게 된 문제>
https://www.acmicpc.net/problem/1026

설명은 되게 장황한 느낌인데, 막상 풀어보면 별 거 없는 문제.
우선 S라는 함수에 대해서 알아야 한다. 이 함수는 크기가 같은 배열 A와 B를 같은 순번끼리 짝지어 곱한 것을 다 더한? 것을 의미한다.

S = A[0] × B[0] + ... + A[N-1] × B[N-1]
수식으로는 이런 모양새가 나온다.

여기서 우리가 할 일은, A만 재배열해서 S의 최솟값을 구하는 것이 문제이다.


사실 문제를 보면, 척수반사로 가장 작은 값과 가장 큰 값을 곱하게 하면 되는 게 아닐까? 하는 생각이 떠오른다. 그리고 그게 정답이다. 딱 그렇게만 알고리즘을 짜면 이 문제는 통과된다.
그런데 혹시 이 문제가 너무 단순하게 풀려서 의문을 가지는 사람이 있을까봐, barkingDog님은 수학적인 증명도 덧붙여주었다. 바로 재배열 부등식이라는 건데, 딱 함수 S와 같은 상황이 주어졌을 때 큰 원소끼리 매칭한다면 결과값이 최대가 되고, 큰 원소와 작은 원소끼리 매칭시키면 결과값이 최소가 된다는 부등식이라고 한다. 사실 왜 이런지는 굳이 설명치 않아도 감이 올 테니 설명은 여기까지만.

근데 문제를 잘 보면, A를 재배열하는 게 핵심이고, B는 절대 움직이지 말라는 말이 나온다. 그래서 풀다가 "설마 B배열을 정렬해서 풀면 안 되는 건가?" 하는 생각이 들긴 했었다.

결론부터 말하자면 정렬해서 풀든 말든 상관없다.
잘 생각해보면, A와 B를 정렬해서 풀어도 결국 다시 B의 순서를 원래대로 되돌리면 A만 재배열한 것처럼 나오기 때문이다. 사실 저 문장을 반드시 지켜서 풀어야 한다고 해도 결국 지금 나처럼 A와 B를 정렬해서 푸는 편이 훨씬 쉽고 편하다. 





<코드 설명>
aArray가 A, bArray가 B.
barkingDog님의 경우 둘 다 sort로 순행정렬을 한 다음 인덱스를 거꾸로 쓰는 방식을 사용했지만, kotlin에서는 역행정렬이 너무 과하게 쉬워서 그냥 역행정렬하고 풀었다.

이후 for문을 돌려서 ans에 aArray[it] * bArray[it]를 전부 더한 걸 출력하기만 하면 된다.
