<BarkingDog님의 알고리즘 강의로 풀게 된 문제>
https://www.acmicpc.net/problem/1929

어제 풀었던 문제가 주어진 수가 소수인지 아닌지를 판별하는 문제라면,
이번 문제는 범위 내의 수 중 소수가 누구인지를 출력하는 문제이다.
범위 지정 형식으로 바뀌었다고 보면 될 것 같다.

하나의 숫자가 소수인지 아닌지 판별하는 건 그냥 그 수의 제곱근 이하의 숫자들로 나눠보면 된다. 하지만 범위 내의 숫자라면 이 방법보다 '에라스토테네스의 체'라는 것을 통해 고른 수의 배수들을 전부 쳐내는 방식으로 작업하는 편이 낫다.

에라스토테네스의 체만 성실하게 구현하면 바로 풀린다.


<코드 설명>
에라스토테네스의 체를 위한 bool 배열은 1-indexed여야 훨씬 편하기 때문에 이쪽으로 작업하는 편이 낫다. 그래서 primeArray가 end + 1이다. end까지의 숫자를 담아주기 위해서.

이후로는 체 구현인데, 그 전에 primeArray[1] = false라는 말이 보인다.
이건 체로 거르는 알고리즘의 시작값이 2이기 때문이다. 1은 소수가 아니기도 하고, 체에 1이 들어가면 모든 수를 다 걸러버리기 때문에 문제가 된다. 하지만 1은 소수가 아니기 때문에 primeArray에서 true로 존재해서도 안 된다. 그래서 앞쪽에서 미리 작업을 해 주는 것. 물론 0은 아예 범위 내에 들지도 않으므로 따로 처리해주지 않아도 된다.

다음에는 cnt 변수를 선언하고 2로 세팅한 이후, 어제 푼 1978번 문제처럼 (cnt * cnt <= end)를 조건으로 단 while문을 시작한다.  ----1

while문 안에서는 cnt에 해당하는 숫자가 소수가 아닌 수로 판별된 적 있는지를 묻는다. 이미 걸러졌다면 그냥 넘기고, 아직 소수인 채로 남아있다면 해당 수를 가지고 체를 치기 시작한다. ----2  체를 치면서 cnt의 배수는 전부 false로 바꿔서 위에 있던 if문을 넘길 수 있게 해준다.
그리고 for문이 끝나면 cnt를 늘려준다.

마지막 for문은 출력을 위한 정리이다. 여기서는 그냥 start와 end의 범위를 사용해도 무방하다. 여기서 소수인 수들은 해당 수의 인덱스를 미리 BufferedWriter 타입으로 선언해둔 bw 변수에 기록해두고, 맨 마지막에 flush를 해서 출력한다.




<주의사항>
1-1. 이 부분에서 start ~ end가 되도록 for문을 써주면 안 된다. start ~ end로 for문을 써주면 start 이하 소수들의 배수들은 체로 걸러지지 않게 된다. 만약 start가 3이라면 2의 배수들은 하나도 걸러지지 않는 것이다. 

1-2. 또한 2부터 end까지 쭉 달리는 것도 안 된다. end가  백만인 경우, 백만과 근접한 소수가 Int의 범위를 초과해버리기 때문이다. 예를 들어 대략 999000정도의 숫자에 소수가 존재한다면, 이를 제곱하면 못해도 9천억 정도가 나온다. 물론 Long 단위를 쓰면 이 부분은 해결할 수 있지만, 더 중요한 것은 굳이 여기까지 조사할 필요가 없다는 점이다.

우리가 1978번 문제를 풀면서 알게 된 점은, 어떤 수가 소수인지 파악하기 위해서는 그 수의 제곱근 이하의 숫자들로 나눠보면 된다는 것이었다. 이 이론은 이번 문제에도 적용할 수 있다. end 이하의 수들이 소수인지는 이 값의 제곱근까지만 체를 쳐도 알 수 있다는 것이다. 그래서 문제에 주어진 최대값인 백만 기준으로는 제곱근 이하인 1000정도까지만 반복문을 돌아줘도 충분히 가능하다.



2. 체를 치는 for문을 잘 보면, 시작 지점이 cnt * cnt로 되어 있고, step cnt로 되어 있다. 
우선 cnt * cnt로 시작하는 for문은 barkingDog님이 알려 준 '에라스토테네스의 채를 개선하는 방법'이다. 예를 들어 2와 3을 지워버린 이후에 4를 넘기고 5로 가보면, 5의 경우 10, 15, 20, 25, 30, 35...등등의 숫자들을 지워야 하는데, 잘 보면 이미 25 이후의 숫자들은 지워져 있다. (10, 20은 2에서, 15는 3에서). 이들이 이미 지워져버린 이유는 이 숫자들이 5보다 작은 소인수를 가지고 있었기 때문이다. 그래서 5에서는 이 숫자들을 신경쓰지 않고 5 이상의 소수만을 가진 수 중 가장 작은 수인 5의 제곱에서 시작하기만 하면 되는 것이다. 

그리고 step cnt는 그냥 cnt의 배수만큼 점프하면서 지우는 거니까 체를 구현한 것이다. 


<제출>
오늘은 한 방에 맞았다.
심심해서 제일 끝 범위를 지정해봤다가 터져버린 에러 덕분에 주의사항의 1번을 깨닫고 수정했고, 1이 문제가 될 수도 있을 것 같다는 직감이 들어서 primeArray[1] = false을 추가하고 제출했더니 바로 성공했다.













