투 포인터. 오늘은 바빠서 투 포인터 문제를 하나 더 풀어봤다.
근데 이번 문제는 투 포인터를 적극적으로 활용해서 푸는 문제는 아닌거같다는 느낌도 든다.

문제는 다음과 같다.
이 문제에서 말하는 '올바른 배열'이라는 말은 배열 속의 원소 중 연속되는 원소가 5개 존재하는 것을 의미한다. 배열이 주어지면, 해당 배열을 올바른 배열로 만들기 위해 필요한 숫자의 최소 갯수를 출력하면 된다.

사실 실버 4이기도 하고, 투 포인터 문제가 쪼금 익숙해지기도 해서 그냥저냥 잘 풀릴 줄 알았는데, 생각보다 봐야 할 지점이 많았다.

우선 숫자를 읽었을 때 그 수가 "연속할 가능성이 있는 숫자"인지를 파악할 필요성이 있다. 예를 들어
{1 2 5 10 11 12}이라는 배열 하나를 두고 있다고 가정하면...
숫자 5를 지정하고 그 다음 수를 하나하나 읽을 때, 5 다음 숫자가 10이면 절대로 5개의 연속을 만들어낼 수 없게 된다. 그래서 이런 부류의 숫자들은 쳐내야 한다.

또한 그 숫자가 가능성이 있다면, 몇 개의 숫자를 채워넣어야 가능한건지도 미리 파악해둬야 한다. 위 예시에서 1을 골랐다면, 다음 숫자 2나 5를 보고 몇 개의 숫자가 더 추가되어야 하는지, 기준 숫자에서 5연속이 달성된건지도 파악해야 한다.

고민할 지점이 많지만, 여튼 고민 잘 했더니 잘 통과했다.



<코드 설명>
우선 입력 받아주고...
lim과 nums를 선언한 이후 lim == 0을 조건으로 단 if문이 있는데, 이 if문은 혹시나 몰라서 넣었다. 얘들 가끔 0으로 장난쳤던거같아서.

다음 nums를 입력받고 정렬한다. 투 포인터에서 정렬이란 기본소양.

이후 빈 숫자가 몇 개인지를 체크하는 emptyCnt와 숫자가 5연속을 달성한건지 확인하는 ficeCnt를 선언하고, 답을 저장할 ans도 선언한다.
그리고 for문으로 루프를 돌기 시작한다. ----1

for문 하나 걸릴 때마다 empty는 0으로, five는 1로 리셋한다. 
five만 1인 이유는...시각적으로 5연속이 모였다는 걸 보여주려면 카운터에 5가 저장되는 게 맞기도 하고, 이후에 5연속까지 몇 개가 모였는지를 파악하는 게 목적인 변수라서 그렇다. 이 for문에 들어왔다는 것은, 이미 i번째 숫자를 1번째 연속으로 잡고 생각한다는 뜻이므로.

이후로는 for문으로 걸린 숫자 기준 뒤쪽의 숫자들을 대상으로 for문을 돌린다. 
이후론 지금 보는 숫자 - 기준 숫자가 5 이상이면 break로 내보내고, ---- 2
그게 아니라면 emptyCnt와 fiveCnt를 적절하게 채운다. ---- 3

그리고 ans의 값과 emptyCnt + (5 - fiveCnt)를 비교해서 더 작은 쪽을 저장하고, 이 ans를 loop 종료 이후 출력하면 된다. 이 때 emptyCnt + (5 - fiveCnt)는 추가해야 할 숫자의 갯수를 나타내는 공식이다. ---- 4









<주의사항>
1. 혹시 5연속인 묶음 하나를 찾았다면, 그만큼 건너뛰고 찾아도 되는 거 아닌가요? 같은 생각을 할 수도 있다. 아쉽게도 그건 안 된다.

{1 4 5 6 8}
배열이 위처럼 나올 경우, 1 4 5 조합보다 4 5 6 8 조합이 좋을 것이다.
이래서 하나하나 살펴봐야 답이 나온다. 물론? 전체 배열 수가 50정도밖에 안 되서 다 돈다고 해도 큰 문제는 없을 것이다.


2. 
if (nums[j] - nums[i] > 4)
이 부분은 "연속할 가능성"을 보는 부분이다. i 기준으로 4를 초과한다면, 그 숫자는 가망이 없는 숫자라서 for문을 나가는 편이 낫다. 내 코드의 반복자가 조금 이상하게 보일텐데, 이 조건이 있기 때문에 저렇게 끝까지 보내도 괜찮다. 아무리 작은 숫자여도 어차피 언젠가는 저 조건에 걸리기 때문이다. 정상적인 5연속이라도 6번째 숫자가 5를 초과하므로 저 조건에 걸려서 break된다.


3. emptyCnt는 '빈 숫자가 몇 개 있는지'를 세는 카운터이다. 숫자간의 차이 - 1을 통해 중간에 몇 칸의 숫자가 비어있는지를 확인한다. 5 7이면 7 - 5 - 1 = 1이니까 5와 7 사이에는 한 칸의 숫자가 비어있다는 사실을 알 수 있다.

fiveCnt는 5연속까지 몇 개의 숫자가 채워졌는지를 체크하는 표이다. 5 7이면 
7 - 5니까 2개의 숫자가 추가로 채워지고, 미리 넣어둔 1을 쓰면 총 3개의 숫자가 채워졌다고 생각하면 된다. 채워졌다...는 말을 좀 풀어쓰자면, 5 7의 경우 숫자 하나만 채워넣으면 5 6 7이 되니까 5연속까지 3개의 숫자가 채워진걸로 볼 수 있다. 이런 원리를 통해 숫자를 채운 것이다.


4. emptyCnt + (5 - fiveCnt)
empty는 그냥 추가해야 할 숫자들을 기록하는 거니까, 더해주면 된다.
five의 경우 5연속을 위해 채운 숫자니까, 5에서 fiveCnt를 빼면 5연속까지 남은 숫자가 된다.

이 부분을 이렇게 둘로 나눈 이유는, 5 7 9처럼 사이사이가 비어서 채워야 하는 경우와 3 4 5처럼 연속하지만 숫자가 모자라는 경우가 있어서, 이를 둘 다 커버하기 위한 방침이다.
예를 들어 5 7 9의 경우 숫자가 2개 필요한데, 이 경우 emptyCnt = 2, fiveCnt = 5가 되서 2 + (5 - 5) = 2가 나온다. 
또한 3 4 5의 경우에도 숫자가 2개 필요한데, 이 경우 emptyCnt = 0, fiveCnt = 3이라서 0 + (5 - 3) = 2가 나온다.
