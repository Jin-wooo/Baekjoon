<Barking님의 알고리즘 강의로 풀게 된 문제>
https://www.acmicpc.net/problem/1629

사실 정말 별 거 아닌 문제인데,
너무 단순한 걸 놓쳐서 이틀이 걸리고 말았다.

문제는 a^b mod c의 결과값을 내는 것인데,
a, b, c 셋 다 int의 최대값까지 예시로 줄 수 있다는 점이 문제였다.
즉, 오버플로우를 얼마나 잘 처리할 수 있는지를 살펴보려는 문제.
이렇게만 말하면 되게 쉬운데, 왜 못푼건지...



이번 문제는 재귀함수로 풀었다.
아래의 함수가 바로 문제의 핵심이 되는 재귀함수다.

int moder(int& a, int b, int& c) {
	int tmp;
	if (b == 1) {
		return a % c;
	}

	long long ltmp;
	if (b % 2 == 0) {
		tmp = moder(a, b / 2, c);
		ltmp = pow(tmp, 2);
		return ltmp % c;
	}
	else {
		tmp = moder(a, (b - 1) / 2, c);
		ltmp = pow(tmp, 2);
		return (ltmp % c) * a % c;
	}
}
처음에는 moder를 이런 식으로 만들었다.
이 moder의 문제점은
1. 너무 길고 복잡하게 만들었다.
b % 2 == 0으로 저렇게까지 복잡하게 할 필요가 없었다.
어차피 abc는 다 int라서 2로 나눠도 소숫점은 없어지니까 tmp에 값을 할당하는 부분은 전부 통일해도 된다.

2. pow가 값을 죄다 꼬아놨음.
가장 큰 차이점은 위인데 가장 큰 문제는 얘인거같다.
다 풀고 난 지금에서야 계산해보니까...

2147483646 2147483646 2147483647
이 입력을 주면 값이 1이 나와야 하는데, 내 꺼는 아마 되도 않는 이상한 숫자가 나왔던 걸로 기억한다.
이 숫자를 연산하던 도중 pow 계산에서 문제가 보였는데

pow(2147483646, 2) =      4,611,686,009,837,453,312
2147483646 x 2147483646 = 4,611,686,009,837,453,316

뒤의 값이 왜인지 4차이가 난다.
이건 아마 pow로 계산하면 부동소숫점으로 튀어나오고, 컴퓨터는 원래 소숫점 계산이 자주 꼬이니까 그 부분에서 문제가 발생하는 걸로 알고있는데...
여튼 꼬인다. 심각하게.


아, 나는 이게 long long으로 리턴하는 것도 중요하다고 생각해서 그 부분도 고쳤는데
내가 모든 리턴값을 지속적으로 c로 나눈 나머지를 리턴했으므로
moder는 int를 리턴해도 괜찮았다.
결국 내 논리도, 이론도, 생각도 다 괜찮았는데 pow가 다 망쳤다는 결론이 나오네.


암튼, 개선한 코드는 이쪽이다.

int moder(int& a, int b, int& c) {
	if (b == 1) return a % c;
	long long tmp = moder(a, b / 2, c) % c;
	if (b % 2 == 0) return tmp * tmp % c;
	else {
		return (tmp * tmp) % c * a % c;
	}
}

짧고 간결하며, pow같은 건 지워버렸다.
이렇게 짧게 잘 쓰일 수 있는 걸 웨 어제는 그렇게 힘들게 작업한걸까
잘 모르겠다.

근데 사실 이것도 barking님의 코드를 한두줄 정도 보고 힌트를 얻은 거라...
기회가 되면 또 풀어봐야 할 것 같다.
pow 하나로 이렇게까지 꼬일줄은 몰랐지.









