<BarkingDog님의 알고리즘 강의로 풀게 된 문제>
https://www.acmicpc.net/problem/7662

이중 우선순위 큐.
우선순위가 높음, 낮음. 이렇게 둘로 이루어져있는 독특한 큐를 말한다.
이번 문제는 그냥 이걸 구현하기만 하면 된다.

C++에서는 정말정말 간단하게 된다. 
multiset이라는 구조체가 이 문제에 완전 최적화된 자료구조라 그렇다.

하지만...kotlin에서는 이야기가 좀 달라진다.
아쉽게도 kotlin에서 set이라는 구조체는 절대로 중복을 허용하지 않는 구조체이기 때문이다. kotlin에는 LinkedSet, HashSet, SortedSet, MutableSet. 이렇게 종류만 5가지는 넘어가는데.... MultiSet은 없다. 
그러니까 kotlin을 쓰는 사람들은, MultiSet 없이 숫자를 여러 개 담을 수 있는 set을 얼추 구현해야 한다는 뜻이다.

나는 어제 시간이 촉박해서 자료구조를 제대로 생각해내지 못하고 밤을 넘기고 말았다.
그러고 오늘 아침에 좀 생각해봤는데...
TreeMap이라는 Collection이 괜찮은 대안이 될 것 같아서 이걸 사용해보았다.

왜 다른 Set이 아닌 TreeMap인가? 하면...우선 Set을 쓸 수 없다는 문제가 제일 크다. 중복을 막아뒀으니까. Set보다는 중복을 간접적으로나마 표현할 수 있는 Map이 낫다. 그리고 Tree속성을 가진 자료구조라서 그렇다. Tree = 이진 트리라 입력하면 자동으로 정렬해준다. 

그래서 TreeMap을 어떻게 쓰는가 하면, 입력이 들어오면 들어온 값을 키로 써서 value를 1로 만들어준다. 그리고 중복이라면 이 value값에 +1을 해 준다. 마찬가지로 삭제한다면 -1, 1에서 삭제하면 해당 키값을 아예 삭제해버리는 방식으로 진행하면 된다.
딱 요정도. 요정도만 구현해주면 된다.

다만 TreeMap은 일반적인 Kotlin.Collection의 자료구조가 아니니 주의.
java에 있던 애였다.




<예제>

3
7
I 1
I 9
I 45
I -5
I 2
I 999
I 6
4
D -1
D 1
D -1
D 1
6
I 1
I 1
I 2147483647
I 1
D 1
D 1

ans : 
-5 999
EMPTY
1 1