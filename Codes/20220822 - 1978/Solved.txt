<BarkingDog님의 알고리즘 강의로 풀게 된 문제>
https://www.acmicpc.net/problem/1978

소수인지 판별하는 문제.

핵심은 판별할 수의 제곱근 이하의 숫자들로 나눠봐서 나누어떨어지지 않으면 소수인 것.
여기까지는 알고 있어서, 보통 나는 이걸 sqrt(N)같은 식으로 풀곤 했었다. 아, 근데 barkingDog님은 이 방법이 살짝 부정확할 수도 있다는 말을 했다.
sqrt는 소숫점 이하로 내려가니까, 숫자가 소실될 수도 있으니 되도록이면 쓰지 말고, 대신 소숫점 없이 판별할 수 있도록 i * i <= n같은 식을 사용하라는 말을 했었다. 이런 문제를 풀면서 거의 생각해본 적 없는 문제였는데. 좀 배워가는 느낌이 든다.

저렇게 판별하는 거만 기억하면 사실 문제는 쉽게 풀릴 것이다.



<코드 설명>
입력은 입력대로 받는데,
지난번에 0 이후로 아무런 입력도 주어지지 않아서 죽었던 게 갑자기 생각나서 주어지는 수가 아예 없어서 Exception이 터지는 걸 막기 위해 따로 처리를 해 주었다.

주어지는 수가 0이 아니라면 다시 입력을 받아서 Int List로 만든다.

이후 소수 판별을 위한 변수들을 준비하고 판별을 시작한다.
사실 내 코드처럼 저렇게까지 복잡할 필요는 없다.
barkingDog님의 예제처럼 소수 판별 영역을 따로 함수로 만들고, 그 부분을 탐색해도 충분히 괜찮다. 그렇게 하면 아마 chk나 ans같은 숫자는 필요 없을지도 모른다.
나는 코드를 어느 정도 본 상태로 최대한 배끼지 않게 짜느라 이렇게 살짝 꼬인 느낌의 코드가 되었다.

아마 for문까지는 별 문제 없어보여도 이후의 cnt = 2나 while문은 뭔가 이상하게 보일 지도 모른다. 저렇게 코드를 짠 이유는, kotlin이 

for (int cnt = 2; cnt * cnt < iter; i++)
이런 식으로 조건을 추가적으로 달아주는 게 어려워서 그랬다.
즉 

cnt = 2
while (cnt * cnt <= iter)
이게 위랑 같은 의미라는 뜻. 아마 kotlin도 저렇게 간결하게 할 수도 있겠지만, 지금 내가 아는 방법은 아니니까.

암튼, while문에 들어오면 대상이 되는 수의 제곱근 이하의 수들로 하나하나 나눠보기 시작한다. 여기서 하나라도 나누어떨어진다면 이 수는 소수가 아니므로 바로 chk를 false로 만든다. chk는 while문 아래에서 쓰이는데, 소수라면 chk가 true로 유지되어 있을 것이므로 ans++이 작동하고, 아니면 그냥 지나간다.

이렇게 ans에 소수들의 갯수가 다 모이면, 그걸 출력해서 마무리.


<제출>
으엒! 제출해볼까! 하다가 cnt++조차 넣지 않은 괴랄한 코드를 제출했다는 것을 깜빡했다. 물론 바로 다음번엔 제대로 수리를 다 한 다음에 제출했다.
집중해서 코딩하자. 

