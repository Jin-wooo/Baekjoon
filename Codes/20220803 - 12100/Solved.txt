<BarkingDog님의 알고리즘 강의로 풀게 된 문제>
https://www.acmicpc.net/problem/12100


이번 문제는 너무 복잡해서 생각만 하다가 6일쯤 쓴 것 같다.
집중은 둘째치고 뭔가 문제를 해결하는 논리를 제대로 세우지 못했던 것 같다.

사실 원리 자체는 고전할만한 물건이 아닌데...



결국 전부 다 돌려보는 게 답인 문제다.
어찌 보면 지난번에 풀었던 15683 - 감시와 결이 비슷하다.
악으로 깡으로 싹 다 돌려보지 않으면 풀리지 않으니까.
감시는 뭔가 '사실 빨리 가는 방법이 어딘가에 있지 않을까?' 하는 희망을 좀 품게 되는 문제인데, 그에 비해 이 문제는 대충 생각해봐도 무적권 싹 다 돌려보는 것 외에는 방법이 없어보인다는 점에서는 쪼금 더 낫다고 본다.


그런데 이걸 어떻게 다 돌리지? 같은 생각을 하면서 시간만 너무 날렸다.
지난번 백트래킹과 재귀함수 시절부터 계속 재귀함수로만 문제를 풀다 보니까 이번 문제도 자꾸 재귀함수로만 생각하게 되었다. 예전에 알고리즘 문제를 풀다 보면 재귀함수로만 모든 걸 해결하려고 하는 병에 걸린다는 말을 들은 적 있었는데, 지금 내가 그런 느낌인 게 아닐까...

암튼 풀다풀다 내가 논리를 정상적으로 못세우고 계속 헛발질을 하는 바람에 정신차리고 barking님이 문제를 어떻게 해결했는지를 보러 갔다.


요약하자면 barkingdog님은 감시를 풀 때와 완전히 같은 방법으로 해결했다.
 '최대 횟수만큼 그냥 깡으로 돌리고, 이 때 4진수 기법을 사용해서 방향의 순서를 정하는' 방법 말이다.

이건 내가 지난번에 비슷한 문제를 풀어서인지 확실히 이해가 갔다.
하지만 이대로 풀면 내 자존심이 뭔가 용납을 못하는 느낌이라...
하던 재귀방식을 그대로 쭉 이어가기로 했다. 그 때 즈음에는 뭔가 좀 더 잘 풀렸다. 이 방식이 완전히 잘못된 방식이 아니라는 걸 다른 풀이를 통해 알게 된다는 느낌은 신기했다.



<코드 설명>
깡으로 재귀함수를 돌린다. 이름은 slider.



암튼 그렇게 문제를 풀다가 오늘 제출하게 되었는데,
첫 제출은 77% 정도까지 가다가 틀렸었다.
왜 틀린걸까? 싶어서 좀 살펴봤는데,

1
16
이걸 주면 0을 출력했다.

즉, 딱 한 칸으로 이뤄진 경우 가장 큰 값은 그 한 칸의 값으로 나와야 하는데
0으로 나왔다는 것은 가장 큰 값의 갱신에 문제가 생겼다고 볼 수 있다.

그래서 확인해봤더니

gamePad[step][y][x] = 0;
if (tmpList[y][x] != 0) {
	if (tmpList[y][x] != pastVal) {
		gamePad[step][y][slideIdx++] = tmpList[y][x];
		pastVal = tmpList[y][x];
	}
	else {
		gamePad[step][y][slideIdx - 1] = pastVal * 2;
		pastVal = 0;
		if (cnt < gamePad[step][y][slideIdx - 1]) {
			cnt = gamePad[step][y][slideIdx - 1];
		}
	}
}
이 코드에서 cnt관련된 부분이 문제였다.
코드를 살짝 설명하자면 y와 x는 for문의 iterator고
지정된 방향에 맞게 gamePad[step - 1](즉, 이전 작업물)을 회전시킨 tmpList를 오른쪽으로 슬라이드한 값을 gamePad[step]에 옮기는 일을 수행한다.

만약 맨 처음 if문에서 걸린다면, 그 부분은 0이 아니라는 거니까 관련된 처리를 해준다.

이후 혹시 내 앞 숫자가 나와 다르다면, 그냥 쌓일 수 있게 담아둔다. 여기서 x축 인덱스가 x가 아니라 slideIdx인데, 지금 이건 슬라이드를 했다는 것을 가정하는 것이므로 x값이 아니라 다른 인덱스를 사용해야 한다. 이 slideIdx는 숫자가 있을 때만 사용되고, 사용된 직후 바로 ++를 해서 다음 사용을 대비한다. 그리고 합쳐지는 경우를 대비해서 pastVal에 값을 저장한다.

혹시 같다면, 그건 합쳐질 수 있다는 의미이다. 물론 같기만 하면 다 합쳐지는 건 아니고, 한번 합쳐지면 그 다음에는 pastVal을 0으로 만들어서 문제가 원하는 방식을 구현했다.(여기서 pastVal이 초기화되지 않으면 2 2 2가 나왔을 때 원하는 대로 4 2가 아니라 4 4같은 괴랄한 방향으로 합성된다.
여기서 sildeIdx는 ++을 하지 않는다. 내 앞의 값을 수정하느라 지금 자리에 값을 채워넣지 못했기 때문이다.


그리고 0이면 그냥 gamePad[step][y][x]를 0으로 만드는 것 외에는 달리 일을 수행하지 않는다. 딱히 처리할 일이 없어서 그렇다. 0으로 만드는 걸 반드시 수행하는 이유는 이 코드가 gamePad[step]을 매번 덮어씌우는 방식으로 작동하기 때문에 0이라서 아무런 처리 없이 그냥 넘어가버리면 이전 처리때 남아있던 숫자들이 같이 남아버리는 경우가 생기게 된다.



암튼? 틀린 부분을 설명하자면...
지금 cnt 관련 처리가 들어간 부분은 숫자가 합쳐지는 부분이다.
즉 숫자가 합쳐져서 큰 값이 나올때만 cnt를 갱신하려고 생각했던 거다.
잘 생각해보니 말이 안되서, 


if (tmpList[y][x] != pastVal) {
	gamePad[step][y][slideIdx++] = tmpList[y][x];
	pastVal = tmpList[y][x];
}
else {
	gamePad[step][y][slideIdx - 1] = pastVal * 2;
	pastVal = 0;
	
}
if (cnt < gamePad[step][y][slideIdx - 1]) {
	cnt = gamePad[step][y][slideIdx - 1];
}

이런 식으로 한 칸 내려서 제출했다.



그랬더니 또 틀림....ㅠㅠ

저 부분 문제가 아니었던 것 같다. 또 똑같은 77프로 지점에서 틀리더라.

그래서 디버깅을 한참 굴렸는데...

WEST 부분에서 해당 step에 맞는 gamePad가 텅 비어버리는 문제를 발견했다.
아, 생각해보니 회전한 결과값을 tmpList에 저장한 다음, 그 값을 다시 gamePad에 넣는 방식으로 구현한 건데, 나는 그걸 까먹고 WEST에 아무런 처리를 해주지 않았음을 알게 되었다.

그래서 위쪽 switch문에서 남들은 다른 방식으로 넣을 때 WEST에는 그냥 배열 전체를 복사해주는 방향으로 코드를 짜넣었다.




그거 해주자마자 통과되었다.
솔직히 쪼금 쪽팔리더라.




이번 문제에서 한 실수
1. 논리가 복잡한 문제에서 너무 집중력이 떨어진다는 생각이 든다.
2. 내 논리를 내가 못따라갔다. 좀 더 차분하게 정리를 하면서 풀어야 하나?