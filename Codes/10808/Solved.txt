<Barking님의 알고리즘 강의로 풀게 된 문제>

그냥 알파벳 숫자 세는거에요.
사실 개쉽긴 하지.

이렇게 쉬운 문제를 웨 추가설명까지 적고있는가.
그건 barking님이 제시했던 다른 문제를 설명하기 위해서다.




문제 2
주어진 길이 N의 int 배열 arr에서 합이 100인 서로 다른 위ㅣ치의 두 원소가 존재하면 1을, 존재하지 않으면 0을 반환하는 함수 func2(int arr[], int N)을 작성하라. arr의 각 수는 0 이상 100 이하이고 N은 1000 이하이다.

Example)
func2({1, 52, 48}, 3) = 1
func2({50, 42}, 2) = 0
func2({4, 13, 63, 87}, 4) = 1

처음에는 하나 고르고 나머지를 전부 뒤져보는 방식 밖에 생각하지 못했었다.
그런데 이걸 위의 알파벳 문제와 결합해보라고 하니까 실마리가 바로 보였다.

잘 생각해보니 100이 되는 숫자를 찾는거니까, 100 - (자기 자신)이 존재하는지 아닌지만 찾아내면 되는 거다.
지금 생각해보면 진짜 아무나 찾는 수준이겠는데....
이걸 웨 몰랐을까.

이거 코드는 확 지워버려서 어디있는지 모르겠는데
원한다면 지금 당장 짤 수 있을 정도로 쉽다.
그냥 0 ~ 100까지 저장할 수 있는 101칸짜리 리스트를 만들어서
(100 - (해당 숫자))가 있었으면 찾은 거니까 바로 리턴,
그게 아니면 그 숫자의 인덱스에 true든 1이든 표시를 한다.

이렇게 하면 좋은 점이, 이전의 풀이는 O(N^2)인데
이건 O(N)이다. 속도가 확 빨라진다 그거지.