<BarkingDog님의 알고리즘 강의로 풀게 된 문제>
https://www.acmicpc.net/problem/18870

사실 너무 쉬운 문제였는데...
조금만 더 깊이 생각했으면 비벼볼만 했을거같은데...
barkingDog님은 이걸 어떻게 풀었을까? 하고 보다가 사실상 원리를 전부 다 봐버려서 studied로 잡게 되었다.

문제는 좌표 압축을 원하고 있다. 사실 문제 봤을 때는 이해가 잘 안갔는데, 결론부터 말하자면 그냥 주어진 배열의 맨 왼쪽을 0으로 두고, 값이 증가할 때마다 1씩 좌표값을 늘리는 것을 좌표 압축이라고 말하는 것 같다.

예를 들어...
2 4 -10 4 -9
이 숫자의 좌표를 표현하려면 원래는 -10부터 4까지, 15칸이 필요하다. 0 = -10으로 취급하고 좌표를 읽을 때마다 써야겠지. 하지만 좌표 압축을 하면
-10 = 0 / -9 = 1 / 2 = 2 / 4 = 3
같은 식으로 쫙 줄어든다. 이러면 4칸만 있어도 표현이 가능해진다.


이 문제를 푸는 핵심 원리는...
1. 정렬		2. 중복 제거	3. 내 위치 파악.
딱 이 세 가지만 하면 된다.
이거 아무리 봐도 생각해내기 너무 쉬운데, 어쩌다가 다 보고 하게 된건지...

암튼 푸는 과정을 나열해보자면,
우선 정렬을 하고, 중복을 제거한다.
barkingDog님은...아마 중복을 제거할 수 있는 함수를 알고 있겠지만, 굳이 쓰지 않고 직접 중복을 제거하셨었다. 이건 그냥 배열을 정렬한 다음, 이전 값과 현재 값을 가지고 비교하면서 둘이 달라지면 그 값을 새로운 배열에 저장하는 방식으로 작업하면 된다.
물론 kotlin에는 중복을 날려주는 함수가 있다. distinct라고 하는데, 그냥 array든 list든 붙이기만 하면 중복을 싹 날려주는 것 같다. 정렬도 굳이 필요 없으니 그냥 써도 될 것 같다.

    val points = readLine().split(" ").map { it.toInt() }
    val sortedPt = points.sorted()
    val cleanedPt = arrayListOf<Int>()
    var oldVal = 1000000001; var newVal = 0

    repeat(lim) {
        newVal = sortedPt[it]
        if (newVal != oldVal) {
            cleanedPt.add(newVal)
        }
        oldVal = newVal
    }
그래서 원래라면 이렇게 했어야 할 코드가...

    val points = readLine().split(" ").map { it.toInt() }
    val cleanedPt = points.sorted().distinct()

이거 두 줄로 퉁쳐진다.


가장 중요한 게 바로 중복 없이 정렬된 상태로 자기 위치를 리턴하는 것이다.
잘 알겠지만, 이 부분에서 이진탐색이 쓰이게 된다.
여기 이진탐색은 복잡하거나 원래 용도에서 벗어나지 않는다. 그냥 이진탐색이니 늘 하던대로 탐색하면 된다.



<코드 설명>

//distinct를 안 쓴 버전으로 설명함
points는 입력받은 좌표값, sortedPt는 정렬된 좌표값, cleanedPt는 정렬과 중복 제거를 완료한 값들만 담는 arrayList이다. (kotlin은 arrayList에서만 값의 추가와 삭제가 가능하니까)

oldVal, newVal은 중복 제거를 위해서 만든 변수다.
oldVal의 값이 저런 숫자인 이유는, 해당 문제의 숫자 범위보다 살짝 더 큰 숫자이기 때문이다. 이런 숫자를 써야 oldVal != newVal이 성립되서 첫 번째 숫자도 중복되지 않았다고 취급되어 cleanedPt에 들어가게 된다.

이후는 그냥 쭉 이진탐색이다.


