<BarkingDog님의 알고리즘 강의로 풀게 된 문제>
https://www.acmicpc.net/problem/11652

가지고 있는 숫자 카드들 중 가장 많이 가지고 있는 카드의 정수값을 출력하는 문제. 눈여겨봐야 할 점은 카드의 숫자 범위가 -2^62 ~ 2^62니까...거의 반드시 Int를 쓰면 안된다.

이 문제를 처음 접하게 되면, 아마 생각할 수 있는 가장 단순한 방법은 그냥 매번 하나하나 세서 가장 큰 수를 기록해두는 것이다. 예를 들어 {16 5 15 5 7 7 16 5 543 5} 같은 숫자가 있다면, 처음 만난 16을 저장해서 몇 번 나온건지 세고, 다음 5를 저장해서 몇 번 나왔는지 세고...하는 방식 말이다.

근데 그렇게 하면 아마 1초 안에 풀긴 쉽지 않을 것이다. O(N^2)가 나올 테니까. 한번 센 숫자들은 다시 세지 않도록 어딘가에 숫자들을 저장할 필요성도 있을 것이고.

그럼 어떤 방법이 더 좋을까? 바로 미리 가지고 있는 카드들을 정렬하는 것이다. 정렬한 다음 세면 카드 하나의 갯수를 세기 위해 배열 전체를 돌아다니거나 할 필요가 없어지니까. 그냥 배열을 한 번만 싹 훑으면 카드들의 갯수를 셀 수 있다.

그러니 결론은, 이 문제를 푸는 방법이 '정렬 후 카드 갯수 세기'라는 것이다.



<코드 설명>
입력을 받고,
배열을 정렬하고,
숫자를 센다.

이게 전부다.



아 근데 이 문제를 한번 틀렸었다.
왜냐면 처음에는 마지막에 센 숫자를 검사하지 않았기 때문이다.
예를 들어...

4
-4
1
1
1
이 되면, 정렬도 저 순서로 될텐데, 내가 올린 이전 코드대로라면 마지막 숫자를 갱신한 다음에는 그 숫자가 highCard인지 아닌지를 계산하지 않고 넘어갔었다. 그래서 그 부분을 고치기 위해 마지막에 

    if (highPt < tmpPt) {
        highCard = tmpCard
    }

이 부분을 추가해서 한번 더 검사해줬다.
아마 다른 사람들은 저런 추가 코드 없이 깔끔하게 짰겠지만, 나는 저렇게 마지막에 추가 검사를 하지 않으면 매번 highCard와 비교하는 코드밖에 생각이 안 났다.