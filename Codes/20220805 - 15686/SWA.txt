<BarkingDog님의 알고리즘 강의로 풀게 된 문제>
https://www.acmicpc.net/problem/15686

전날 시작해서 아침에 딱 풀게 되었다.
사실 하루 안에 풀 수도 있었을 텐데, 다른 방법이 없을까 해서 계속 뒤져보다가 늦었다. 게다가 사실상 핵심적인 힌트를 barkingDog님의 강의를 보고 알게 되어서 SWA가 되었고.
그냥...좀 더 공부하고 탐색했다는 것에 의의를 두고 싶다.


문제는 치킨 거리(가장 가까운 치킨집과 집 사이의 거리)를 구하는 건데, 치킨집을 최소한(M)만 남기고 폐점시킬 경우 이 도시의 가장 짧은 치킨 거리는 얼마인가?를 해결하는 문제이다.


이 문제의 핵심은 폐점할 치킨집과 남을 치킨집을 가려내는 방법이라고 생각한다. 나는 여기서 Combination, 즉 조합을 사용한다면 쉽게 풀 수 있을 것 같다고 생각하게 되었고, 그걸 어떻게 하면 구현할 수 있을지를 생각하는 데 시간을 많이 보냈다. (치킨집 전체 갯수)C(남을 치킨집 수) 를 저장한 배열을 for문을 돌려서 탐색해보는 게 최고의 방법이겠지만, 문제는 내가 그 조합의 배열을 만드는 방법을 전혀 모른다는 점이다.

그래서 조합 부분은 포기하고 다른 방법을 생각해보다가, 이대로 계속 보고있기만 하다가는 또 허송세월 보낼거같아서 barkingdog님의 강의를 보면서 어떻게 풀었는지를 보게 되었다.

barkingdog님은 해당 배열의 조합을 만드는 방법은 백트래킹이 있지만, next_permitation이라는 방법을 쓰면 더 쉽게 풀 수 있다면서 해당 방법을 소개해주었다.
처음에는 이게 직접 만든 함수인 줄 알았는데, 알고보니 algorithm 헤더에 포함되어있는 함수였다. 세상에, {0, ... , 0, 1, ... , 1}과 같은 형태로 nCr 을 표현할 수 있게 배열을 만들면 그걸 통해서 바로 조합을 만들어주는 코드였다. 조합을 그냥 퐁 하고 뱉어주는 코드가 있었다니. 몰랐던 함수다. 

이 함수는 단순히 이거 하나만 끄집어내서 사용하는 게 아니라 do while문을 통해 따로 사용하는 방식이 있는 모양이다.

do {
	for (int k = 0; k < vecChick.size(); k++) {
		if (vecComb[k] == 1) {
			// Codes...
		}
	}
} while (prev_permutation(vecComb.begin(), vecComb.end()));

여기서 vecChicken은 조합의 대상이 되는 벡터,  vecComb는 0과 1로만 이루어진 벡터이다. 
저렇게 해 주고 Codes에서 vecChick[k]로 호출해서 사용하면 된다.
딱 저렇게 해줘야 선택된 조합 중 하나가 읽어진다고 생각하면 된다.


그리고 저걸 위해서는 vecComb처럼 0과 1로만 배열을 꽉 채워줘야 하는데, 이 때 사용할 수 있는 방법이 cstdlib의 fill이다. 
	fill(vecComb.begin(), vecComb.begin() + M, 1);
사용방법은 이렇다. 원하는 시작지점과 끝지점을 선택하고, 세 번째 인자로 채울 숫자를 넣으면 저렇게 채워준다. 저건 시작점부터 M칸 떨어진 부분까지 1로 채운다는 뜻. 끝이라면 end와 조합해서 사용하면 된다.



이제 코드를 설명해보고자 한다.

메인 함수의 변수들이 이것저것 있는데,
N, M은 문제에서 제시한 N, M이 맞고,
chickDist는 답으로 제출할 치킨 거리를,
tmpDist는 매 조합마다 계산된 치킨집 하나의 치킨 거리를,
tmpChickDist는 매 조합마다 계산된 전체 치킨 거리를 의미한다.
이름이 좀 헷갈리지만, 여튼 chickDist가 답을 저장하는 부분이다.

city는 보다시피 도시를 저장하는 배열
vecChick은 치킨집을, vecHome은 가정집의 위치를 저장하는 벡터이다.

그 밑의 이중 for문은 city에 제시된 배열을 저장하는 부분이다.
근데 자세히 보니 딱히 도시의 상황을 저장할 필요는 없어보인다.
cin으로 받아온 뒤에 1인지 2인지만 파악한 다음 다 버려도 괜찮을듯?


이후 나오는 vecComb는 앞서 말했듯이 조합을 표현하는 벡터.
vecDist는 각 가정집별로 가장 가까운 치킨집과의 치킨 거리를 저장하는 벡터이다. 이 벡터에 해당 조합에서의 가장 작은 치킨 거리를 구한다음, 그걸 전부 더해서 전체 치킨 거리를 구한다. 그냥 가장 작은 걸 모아두기만 해도 풀린다.

그 아래 fill은 설명했듯이 1을 채워서 조합을 완성하는 부분이고,
다음에 나오는 do while은 prev_permutation으로 조합


