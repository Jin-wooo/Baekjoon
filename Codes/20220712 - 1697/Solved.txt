<Barking님의 알고리즘 강의로 풀게 된 문제>
https://www.acmicpc.net/problem/1697

실버 1따리의 문제에 뭐하다가 이틀이나 쓴건지 이해가 안가는 문제.

문제의 핵심은 출발점에서 대상까지 +1, -1, *2만 써서 가는 것.
나는 처음에 이 문제가 DP같은 건줄 알았다.
작년에 DP에 대해 공부할 때 대충 이런 부류의 문제가 있었던 기억이 난다.

그런데 barking님은 이 문제가 백트래킹도, DFS도 아닌 BFS문제라고 했다.
좀 이해가 안갔는데, 바로 다음에 나온 설명을 듣자마자 이해가 바로 갔다.

우리가 지금까지 풀어온 미로 계열의 문제들은 이동 방향이 상하좌우로 총 4가지였는데, 이 문제도 살짝 다르게 생각해보면 앞, 뒤와 점프로 총 3가지의 이동 방향이 있는 BFS로 생각해볼 수 있다고 설명해주셨다.

이걸 쉽게 생각해내지 못한 건 좀 아쉽다.


이런 원리만 알면 문제 자체는 쉬운 편이다.
난이도도 실버1이고, 알고리즘도 쉽고.
근데 왜 이리 오래 걸렸던거냐면,
이 문제에서 발목을 잡힌 부분이 알고리즘이 아니라 런타임 에러이기 때문이다.

처음 제출했을 때는 OutOfBound가 났었다.
어딘가에서 인덱스 문제났구다는 건 대충 알아차렸다.
잘 생각해보니 0일 때 -1을 해주면 인덱스가 꼬인다는 걸 알았다.
되게 기초적인 건데....왜 생각 못했을까?
그래서 -1을 해주는 부분에는 0보다 크거나 같아야 큐에 넣을 수 있게 해주었다.

그리고 하는 김에 코드를 살짝 최적화해주었다.
예를 들어, 처음에 이 코드를 짰을 때는 listLine에 200001정도로 할당을 해 주었는데, 잘 생각해보면 listLine에 20만개나 할당할 필요는 없다.

1 ~ 49999까지는 2배를 해도 10만이 넘지 않고,
50000은 그냥 2배하면 10만이고,
50001 ~ 75000 언저리까지는 -1을 해서 50000으로 맞추고 2배를 하는 게 낫고
그 이상부터 10만까지는 그냥 10만까지 +1을 하는 편이 더 빠르기 때문이다.

이런 특성은 /2를 할 수 없었기 때문에 생긴다고 본다.
해당 옵션도 같이 있었다면, 반드시 20만 이상의 배열 갯수가 필요했을 것이다.
그리고 비슷한 이유로 10만 이상의 값이 나오면 큐에 넣지 않는 방식으로 구현했다. 그 이상의 값은 쓰이지도 않고 계산량만 늘리니까.



이런 걸 얼추 고치고 제출하니 이번에는 SegFault 에러가 났었다.
아, segfault라니... 어딘가에서 이상하게 접근하는 부분이 있었던 것 같다.
배열에 문제가 생겼나 싶어서 점검도 하고 했는데, 정말 모르겠어서 질문 검색을 통해 살펴보니 큐가 비어있을 때 문제가 생길 수 있다는 말을 확인했다.

난 지금도 이해가 안가는데, 이 문제에서 큐가 비는 예제가 존재할 수는 있는건가 싶다.
큐에 한번에 3개씩 넣고 하나씩 꺼내는 문제에서 큐가 빌 수가 있다니?

근데 예제는 잘 몰라도 어딘가에서는 오류가 날 수 있다니까, 그러려니하고 바꿔주었다.
그리고 listLine[tmpPt]가 꼭 우리가 원하는 값을 가리킬 리가 없다는 걸 깨닫고 listLine[numED]로 교체해주었다. 저것도 약간 실수같다.

그리고 이런저런 예제들을 찾아서 테스트해본 뒤 제출하니...성공!


앞에서 원리를 생각하는 것도 그렇고,
런타임 에러나 반례를 유동적으로 생각하는 것도 그렇고...
더 많은 문제를 풀면서 경험을 쌓는 게 얼마나 중요한지 좀 느끼게 된다.



이번 문제에서 한 실수
1. 질문 검색을 뒤져봄
2. segFault를 너무 고려하지 않았음. 큐가 비는 상황은 항상 체크하자.
3. OutOfBound는 너무 초보적인 실수였음.




