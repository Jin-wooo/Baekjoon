<BarkingDog님의 알고리즘 강의로 풀게 된 문제>
https://www.acmicpc.net/problem/1477

골드 4인데, 내가 풀어본 적 없는 유형의 문제를 2개나 만나서 그랬는지는 몰라도... 정말 어려웠던 것 같다.
요새 실버쪽 문제들만 많이 풀어서 어려운 문제에 대한 대비가 부족했던 건지, 영 힘들었던 것 같다. 애초에 문제 자체에 감도 안 올 정도였으니...



문제를 딱 보면, 우선은 어디에 어떻게 휴게소를 두어야 할지만 생각했었다. 그리고 계속 정확히 3등분, 4등분을 해야 하지 않나? 같은 생각도 들었었고. 그리고 "가장 큰 도로만 골라서 반토막 내 주면 쉽게 해결되지 않을까? 하는 생각도 들게 된다.

이 문제는 잘못된 그리디 문제라서 그런 방식으로 접근해서는 안 된다. 절대 몇 등분으로 나누거나 그리디 한 방식으로는 이 문제를 풀 수 없는 거였다. 예를 들어 도로 길이 1000에 휴게소를 2개 더 지어줘야 하는 상황이라고 가정하자. 이 때 그리디한 방법을 쓰면 500으로 나누고 250으로 나누는? 이상한 상황이 온다. 이렇게 하면 최솟값의 최댓값은 500 정도가 나온다. 물론 이게 답일 리가 없다. 여기서 정답은 3등분 정도로 나눠주는 것이다.

이 문제에서 우리가 변경해줘야 하고 집중해야 하는 부분은 바로 휴게소를 나누는 간격 그 자체이다. 나눠주는 간격 자체를 이진탐색을 통해 탐색하는 것. 그것이 이 문제의 핵심이라고 보면 된다.

barkingDog님은 이 문제가 parametric search라는 방식을 통해 풀 수 있는 거라고 해서 나도 이 탐색법에 대해 공부하면 풀 수 있지 않을까 했는데, 이렇게 생각할 당시에는 잘 안 됐었다. 이젠 이 문제가 왜 parametric search인지 얼추 감이 오는데, 최솟값으로 만드는 최댓값을 찾기 위해 1~(최대 도로 길이)까지의 숫자 중에서 가장 괜찮은 값을 고르는 결정이 parametric search를 이용하는 거라고 생각하고 있다. 물론 이게 맞는지는 잘 모르겠지만...



<코드 설명>
입력은 입력대로 받고, 주의할 점은 if문 부분이다.
미리 지어진 휴게소가 0개일 수도 있어서, 이 부분은 if문으로 처리를 해줬다. 왜 처리했는지는 제출쪽에서 설명할 예정이다. 

if문으로 rester가 0이 아닌 것을 확인했다면, 휴게소 사이의 거리 배열을 만들어준다. 다른 사람들은 그냥 휴게소의 위치 자체만을 받아서 매번 빼서 사용하던데, 나는 그게 좀 불편해보여서 이 배열을 만들게 되었다. resterArray.sort()부터는 그걸 처리하는 부분이다.

혹시 rester가 0이라면, 그냥 거리 배열에는 도로의 길이 하나만을 넣는다.
휴게소가 0개라면 휴게소로 나눠진 도로의 길이 = 도로 전체 길이이기 때문이다.

이후론 이진탐색을 시작한다.
이진탐색 자체는 다들 대충 알 테니까 넘어가겠다.
이진 탐색이 대충 끝나면 그냥 출력하면 된다.

<주의할 점>
1. right와 left를 이동시키는 조건이 휴게소의 갯수다. 많으면 휴게소를 너무 촘촘하게 세운 거라서 간격을 늘려야 하고, 그래서 left = 작은 쪽이 이동한다. 적으면 휴게소가 너무 듬성듬성 세워진 거라서 right = 큰 쪽이 이동한다.

2. 휴게소를 원하는 만큼 지었다고 해서 바로 이진탐색을 종료해서는 안 된다. 백준에 나와 있는 예제가 가장 좋은 예시인데, 이 문제의 정답은 70이지만 71도 7개의 휴게소를 세울 수는 있다. 그래서 바로 종료하면 예제조차 틀리게 된다. 혹시 모르니까 while문의 조건에 의해 튕겨나올 수 있도록 추가로 더 탐색을 해 줘야 한다. 그리고 이 경우 더 작은 숫자를 찾기 위해서 탐색을 진행하는 것이므로 right = 큰 쪽을 줄여준다.

마지막으로 정답은 left로 제출하는데, 이 부분은 사실 명확하게 잘 모르겠다. right를 최후까지 조절한다는 점을 너무 빡세게 이해하느라 이 부분은 헷갈리는 것 같다. 마지막까지 답을 찾기 위해 조절하는 부분이 right여서 그런 게 아닐까 싶다.


<제출>
처음은 컴파일 에러.

두 번째는 이진 탐색의 종료 조건과 범위 축소 조건 (right = mid - 1같은 방식이 전혀 기억나질 않았다. while문의 종료 조건도.)

세 번째는 left를 답으로 제출하지 않은 것. ans같은 게 필요 없었다는 걸 몰랐다.

네 번째는...여기도 좀 주목해봐야 하는데, NumberFormatException, 즉 입력 오류였다. 이건 보통 readLine에서 문제가 생겼다는 뜻이다.

입력 아래쪽의 if문에 주목하자. 왜 뜬건가? 싶어서 봤는데,
알고 보니 미리 세워진 휴게소가 0개일 수도 있다는 조건을 보지 못해서 만들어진 실수였다. 내가 쓰고 있는 readLine의 경우 반드시 원하는 형태의 입력을 받게 만들어진 거라서, 입력이 존재하지 않으면 바로 에러가 난다. 에러가 난 것은 이 부분 때문. 그래서 입력 이후에 휴게소의 갯수를 파악해서 작업한 것이다.

참고로 for문을 통해 입력을 받는 C++의 경우엔 이런 처리를 하지 않아도 된다.
for문이라면 0이 들어갔을 때 실행하지 않고 나와버릴 테니까.