<BarkingDog님의 알고리즘 강의로 풀게 된 문제>
https://www.acmicpc.net/problem/2230

이번 문제는 오랜만에 Solved다.
골드 5 수준의 문제를 혼자 힘으로 풀다니!
라는 말을 다른 사람들이 본다면 되게 허접한 사람처럼 보이겠지만...
최근 푼 문제들이 죄다 Studied였던 나에게는 정말 좋은 소식이다.

barkingDog님이 어떻게 풀었는지를 보기는 했지만...
결국 내가 푼 방식과는 전혀 차이가 없었다.
투 포인터 방식 자체는 이미 내가 알고 있었으니까.


여튼 이번 문제는 두 수를 골라서 뺐을 때, 차이가 M 이상이면서 제일 작은 경우를 출력하는 것이 목표다.
단순히 두 수를 골라서 처리하는 것만 봐서는 이중 for문이 생각나겠지만, 이 문제는 범위가 최대 10만이라서 이중 for문으로는 연산이 100억번으로 뻥튀기되서 도저히 시간 제한을 맞출 수 없게 된다.

그래서 쓰는 방법이 투-포인터!
이 방법은 진짜 포인터를 쓴다기 보다는 인덱스 두 개로 정해진 규칙(문제에 따라 다름)에 따라 배열을 훑으면서 탐색하는 방법을 말한다. 이 방식의 최대 장점은 역시 시간 복잡도를 줄이는 건데, 이중 for Loop처럼 숫자를 2번 순회할 수 있는데도 시간은 O(N)정도로 맞춰진다.

다만 투 포인터를 쓸 수 있는 상황이 약간 한정적이긴 하다.
예를 들어 이 문제의 경우, 이중 for문을 쓰는 것은 확실히 낭비다. 
for (i in list) {
	for (j in list) {
		if (M >= list[j] - list[i]) { ... }
	}
}
이렇게 이중 for문을 만들어서 계산한다고 가정해보자.(list는 정렬됨)
이 경우 문제에서 가정한 대로 M은 반드시 양수여야 하므로 i > j가 되는 순간부터는 계속 음수밖에 나오지 않으니 굳이 돌 필요가 없게 된다.
또한 어느 시점에서는 list[j] - list[i]가 M 이상이 될텐데, 이 부분에 도달하면 j + 1부터는 더 보지 않아도 된다. 문제는 M 이상인 값 중에서 가장 작은 값을 요구하기 때문이다. list[j + 1] - list[i]이면...당연히 list[j] - list[i]
보다는 더 큰 값이 나오겠지.

뭐 이런거 하나하나 다 신경쓰면서 for문을 만들어도 좋겠지만, 저런 문제를 한 방에 해결해줄 수 있는 게 바로 투포인터라고 보면 되겠다.




<코드 설명>

입력 이후, 숫자들을 담은 배열을 정렬해준다.
중요한 부분이다. 이 배열이 정렬되어있어야 투 포인터로 계산하는 게 성립된다.

이후에는 투 포인터를 위한 변수를 만들어준다. 나는 앞쪽 포인터와 뒤쪽 포인터라는 의미로 이름을 frontPtr, backPtr로 지어두었다.

다음으로는 while문을 통해 탐색에 들어간다. ----1
hold에는 두 수의 차를 저장하는데, 원한다면 M + nums[backPtr]로 구해도 된다.
이후 hold값이 target = M보다 크거나 같으면 값을 비교한 다음 backPtr의 값을 올리고, 아니라면 frontPtr의 값을 올린다. 

여기까지만 해도 몇몇 경우에는 답이 잘 나오지만, 가끔 front가 너무 빨리 가버려서 back이 충분히 탐사하지 못하는 경우가 있다. 그런 경우를 대비하기 위해 아래쪽에서 while문을 한번 더 돌려준다. 이 때 앞에서 frontPtr을 빼 준다. ---- 2

이 while문에서는 앞서 했던 것과 비슷한 일을 하지만, 여기 진입했다는 것은 사실상 frontPtr이 끝까지 갔음을 의미하므로 hold에 어떤 값이 오든 backPtr을 계속 상승시켜준다. 물론 hold로는 계속 M값과 비교해준다.

그리고 numMin을 출력한다.


<주의사항>
1. while문의 범위를 어떻게 지정해야 할까?
나는 처음에 frontPtr정도만 건드리면 될 거라고 생각했는데, 잘 생각해보면 값이 0인 경우 backPtr은 거의 매번 front를 넘게 된다. 그래서 front와 back 둘 다 인덱스 범주를 넘기지 못하게 막아줘야 한다. 안 그러면 back 쪽에서 인덱스 에러를 일으킨다.


2. frontPtr을 빼는 이유는, 거의 대부분의 경우 frontPtr이 numLim 이상으로 올라가서 위쪽 while문이 종료되는 경우가 많기 때문이다. 이러면 아래쪽 while문을 실행하다가 frontPtr이 인덱스 밖의 값을 인식해서 튕기는 경우가 생긴다. 그래서 빼 준다.

아, 혹시 frontPtr이 끝까지 가지 못한 상황이라서 backPtr을 위한 while문을 만들어줘도 제대로 탐색을 못하는 게 아닌가 하는 생각이 들 수도 있다. 하지만 이 알고리즘에서 backPtr은 절대로 frontPtr를 2칸 이상 추월하지 않는다. 이미 한 칸을 넘긴 시점에서 둘의 차인 hold가 음수가 되어버리기 때문이다. 그래서 절대로 그런 일은 생기지 않는다. 그리고 backPtr이 frontPtr보다 큰 경우는 보통 front = numLim - 1, back = numLim 정도인 경우에나 생긴다. 그리고 그런 경우는 탐색할 필요가 없다.




<이번 문제에서 실수한 점>
1. while문을 하나로 압축하지 못한 게 아쉽다.
barkingDog님은 나랑은 좀 다른 의미로 투 포인터를 짜셨다. 아마 그 방식이 쪼금 더 간결하고 쉬운 방법인 것 같으니, 다음에는 그렇게 해보려고 한다.






