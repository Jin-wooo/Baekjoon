<BarkingDog님의 알고리즘 강의로 풀게 된 문제>
https://www.acmicpc.net/problem/12852

예----전에 풀었었던 1로 만들기. 그 1로 만들기의 2번째 버전으로,
이번 문제는 주어진 수를 1로 만드는 최소 계산횟수에 추가로 최적의 경로까지 출력해야 한다.

기존의 1로 만들기는 큐를 통해서 풀었다.
그 때는 숫자와 계산 횟수를 가진 구조체를 큐에 넣고, 
해당 숫자가 2나 3으로 나누어떨어지는지, 2나 3인지...그런 것들을 체크해보면서 연산을 했었다. 그래서 어딘가에서 1에 도달하면 그 구조체의 연산 횟수를 불러와서 답으로 제출하고 그랬었다.

이번에도 엇비슷한 방식을 채용해서 풀었다. 
지난번과 다른 점은 원래 문제처럼 2나 3으로 나누거나 1을 빼는 식으로 하는 게 아니라, 1을 기준으로 시작해서 2, 3을 곱하거나 1을 더하는 식으로 해결했다. 그 이유는 위치 기록 때문인데, 목표가 되는 숫자를 나누고 빼는 식으로 하면 경로가 역으로 나온다. 

예를 들어 10이라면...
0 1 2 3 4 5 6 7 8 9 10

이렇게 i-indexed인 배열이 있다고 가정하고,
10을 넣ㅇ면 나오는 값인 1, 3, 9, 10에 원래 문제와 같은 방식으로 나누거나 빼는 연산을 진행하면 배열 상태는 다음과 같아진다.
0 1 2 3 4 5 6 7 8 9 10
  3   9          10    
다음과 같이 나온다.     
이러면 10에서 9를 찾아갈 방법이 없어진다.
1 3 9 10을 출력할 수는 있어도, 10 9 3 1을 출력할 수는 없어진다는 뜻이다.


그래서 반대로 곱하거나 더하는 연산을 사용한다. 그러면...
0 1 2 3 4 5 6 7 8 9 10
  0   1           3  9
이런 느낌으로 나오고, 이러면 배열[10] -> 9, 배열[9] -> 3처럼, 우리가 원하는 순서대로 나온다. 이 문제에서는 이 부분만 주의해서 코드를 짜면 된다.



<코드 설명>
앞쪽에 자잘한 설명이 달린 코드들이 좀 많은데...
보다시피 numTar이 목표가 되는 숫자(입력받은 거)
calcArray가 계산된 횟수를 기록하는 배열
distArray가 계산된 경로를 기록하는 배열
tripleArray는 *2, *3, +1을 for문으로 한 번에 계산하기 위한 배열이다.

numPop은 pop한 값을 저장하고, arrayDeque는 queue다.
arrayDeque에 관한 설명은 아래에 적어두었다. 일단은 queue라고 보면 된다.

그러고 기존 문제를 풀듯이 while문을 돌면서 문제를 해결하면 된다.
다만 나눌 수 있는 숫자인지 아닌지를 굳이 파악해가면서 계산할 필요는 없고, 숫자가 범위를 초과하지는 않았는지, 이 숫자가 기존의 숫자보다 덜 계산해도 되는 숫자인지만 체크하면 된다. 위 두 조건을 만족했다면 그 숫자를 distArray와 calcArray에 적당하게 기록해주면 된다. 그리고 arrayDeque에도 넣고.

그 다음엔 그냥 출력해주면 된다.





<주의사항>
1. kotlin에는 무려 C++같은 방식의 and인 &&와 파이썬의 'and'가 다 있다.
다만 &&는 if (i > 4 && i < 11)
그리고 'and'는 if ((i > 4) and (i < 11))
같은 방식으로 사용해야 한다.
둘의 차이점이 뭔지는 정확히 나오지 않는데...여튼 다른 부분임.
그냥 && 쓰는 게 나한테는 더 이득이라고 생각하고 있다.


2. 이 문제에서 가장 중요한 queue를 담당하는 변수가 arrayDeque이다.
이걸 코틀린으로 풀면서 처음 알게 된 건데, 코틀린에는 엄밀히 말하자면 queue라는 구조체가 제대로 없는 것 같다. 다른 구조체를 queue처럼 사용하거나, Java의 queue를 LinkedList로 호출해서 사용하는 방식이던데... 한 마디로 C++처럼 queue라고 호출할 수 있는 자료구조가 없다는 뜻이다. 혹시 queue가 필요하다면 이 부분을 주의해야 할 것 같다.

그래서 arrayDeque는 뭐냐면, ArrayDeque 타입의 자료구조다. 무려 앞과 뒤 양방향으로 입력과 출력이 가능한, queue의 상위버전 자료구조이다. 그래서 queue가 없는 것이다. 단방향 입출력으로 쓰면 queue가 되니까.




<이번 문제에서 실수한 것>
1. 문제를 똑바로 안 읽어서 제출을 실수했다.
계산 횟수도 출력해야 하더라. 사실 코테에 큰 영향을 주는 실수는 아니겠지만...그래도 문제를 잘 읽고 풀어야 한다는 교훈은 얻었다.


            