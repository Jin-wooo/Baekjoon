<BarkingDog님의 알고리즘 강의로 풀게 된 문제>
https://www.acmicpc.net/problem/2217

로프 문제.
각 로프가 들 수 있는 최대 중량이 주어졌을 때,
이 로프들을 사용해서 들 수 있는 물건의 최대 중량을 구하는 것이 문제다.

로프의 경우 k개의 로프로 중량이 w인 물건을 들어올리면 각 로프에는 w/k의 중량이 걸리게 되는데, 내 생각에는 이 말이 무슨 말인지를 빨리 파악하는 것이 문제의 핵심이라고 생각한다.

이 말은 그냥 바꿔말하자면,
고른 로프 중에서 가장 가용 가능 무게가 적은 로프 x 고른 로프 갯수
가 최대 중량이 된다는 말이다.

이 말을 빠르게 알아들었다면, 정말 문제가 간단해진다.
먼저 입력받은 배열을 역순으로 정렬하고,
그 배열에 대해 for문을 돌려서 각 배열의 원소마다 자기 무게 * 로프 갯수를 연산해주기만 하면 된다. 수식으로는 대충 array[i] * (i + 1)같은 느낌.

꼭 for문 전체를 돌려줘야 한다.
다 돌려야만 최대값이 나오는 경우가 종종 있다.
5
3
1
1
1
1
이 경우 처음에는 3, 두 번째는 2가 되지만, 마지막까지 가면 5가 된다.
이런 경우가 있을 수 있으니, 값이 작아졌다고 바로 break를 걸면 안 된다.



<코드 설명>
논리가 간단해서 코드도 쉽다.
아마도 repeat까지는 대충 알 수 있을 것이고...
sortDescending은 그냥 kotlin에서 역순정렬을 하는 함수이다.
그리고 이후에는 이전의 최대 무게를 담고 있는 numWeight와 이번 반복자에 해당하는 로프 무게로 새로 연산한 무게 중 어느 쪽이 더 큰지 비교해서 numWeight에 담아 둔다. 이 작업을 for문 전체에 반복한 다음, 답을 도출한다.

추가 - kotlin에서의 sort
sort 함수에서 정렬하는 방법을 따로 지정해주는 것으로 모든 것을 해결하던 C++과는 달리 kotlin에서는 역순정렬을 위한 함수가 따로 존재한다. 혹시 kotlin으로 알고리즘을 해결할 생각이라면, 한번쯤은 kotlin의 정렬 함수에 대해서 공부해 볼 필요가 있다고 본다. sort와 sorted, 그리고 by, with, Descending같은 접미사가 결합해서 수많은 바리에이션을 만들어내기 때문이다.



<제출>
이번 문제도 한 번 틀렸다.
이번 문제가 틀린 이유는 앞서 말한 for문 전체를 돌려주지 않고,
        if (numWeight < pastWeight) {
            println(pastWeight)
            return
        }
이런 식으로 값이 한 번이라도 작아지면 바로 return을 해버리는 코드를 제출했기 때문이다. 이렇게 되면 위에 적어둔 경우를 해결하지 못하게 된다. 

저렇게 풀게 된 이유는, 한 번이라도 값이 작아지면 다시는 커지지 못하지 않을까? 하는 나의 성급한 결론 때문이라고 본다. 이것도 스스로 알아내지는 못했고, barkingDog님의 코드에서 max를 왜 쓰는건가?를 잘 생각해보다가 알게 된 결론이다. 나처럼 끊어버리지 않는다는 점에서 착안하게 되었다고 할 수 있겠다. 그래서 이 문제도 어중간하긴 하지만 SWA로 책정했다.




<이번 문제에서 실수한 것>
1. 문제를 좀 대충 본 것 같다. 
나는 최대 중량이 각 로프의 가용 가능 무게의 총합 / 로프 갯수로 정해지는 줄 알고 문제를 풀었다. 완전히 잘못된 접근이긴 한데, 문제가 저렇게 나와도 결국은 역순으로 정렬하는 것이 해결의 실마리이기 때문에 문제를 푸는 데에는 도움이 되었다.

확실하게 문제를 이해하고 풀이를 시작해야 시간을 줄일 수 있을텐데. 책을 좀 읽어줘야 하나?



2. 내가 세운 이론을 너무 내가 맹신했다는 생각도 든다.
이번 이론은 분명히 반박할만한 여지가 있었을 텐데, 너무 성급하게 제출했다는 생각이 든다.