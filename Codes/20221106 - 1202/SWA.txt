<BarkingDog님의 알고리즘 강의로 풀게 된 문제>
https://www.acmicpc.net/problem/1202

이번 문제는 보석 도둑이라는 문제이다.
요약하자면 보석을 가방에 넣는 문제이다.
이렇게만 들으면 0-1 knapsack같은 부류의 문제일 거라고 생각하게 되는데,
사실은 보석이 가방에 하나만 들어갈 수 있으므로 조금 다른 부류의 문제이다.

처음에는 TreeMap을 이용해서 보석을 하나하나 받아둔 다음, 그 무게에 맞는 가방을 찾아서 매치해줘야 한다고 생각했다. 

그런데 그렇게 생각해서는 도저히 답이 안나와서 잠깐 barkingDog님의 힌트를 봤더니, 보석이 아니라 가방에 Map을 적용하는 게 정답이라는 말을 듣고 호다닥 적용해보았다. 또 조금 찾아보니 TreeMap같은 이진 트리를 사용하는 구조체들은 해당 숫자 이하나 이상의 숫자를 그 자리에서 리턴해주는 다양한 메서드들이 존재해서, 이걸 사용하기만 한다면 바로 답이 나올 거라고 생각하고 문제를 풀었다.

아...그런데 또 영 안풀리길래 도움을 좀 받았는데, 이 문제는 그리디일 수 밖에 없다는 말도 들었다. 잘 생각해보니, 어차피 싼 거 두개로 비싼 거 하나를 이길 수 있게 넣는것보다는 그냥 비싼 애들로만 잔뜩 넣는 편이 훨씬 좋다는 것도 알게 되었다. 아마 무게 이하로 채워넣을 수 있었다면 다른 양상의 문제가 되었을 것이다. (예를 들어 가방 무게가 5라면, 이 문제는 5 이하의 보석 하나만을 넣을 수 있는데, 내가 말한대로라면 1 + 4도 가능해진다는 뜻)


알고리즘 자체가 정말 쉬운데, 답이 유난히 거지같이 안 나오는 문제였다.



<코드 설명>
변수를 받는 부분과 repeat 부분은 대충 어떤 느낌인지 보일 것이다.
여기서 보석의 목록은 jewelList라는 ArrayList를 통해 받아주었다. 특별히 할 처리가 없기 때문이다. 그리고 이 보석들은 추후 가격과 무게 순으로 정렬해줬다. 이렇게 정렬해준 다음에 처음 보석부터 순회하면 그게 그리디 아니겠는가?

문제를 푸는 알고리즘은 간단한 편이다.

먼저 보석의 무게를 담을 수 있는 가방 중 가장 작은 가방을 고른다.
kotlin은 이를 ceilingEntry라는 메서드를 통해 쉽게 구할 수 있다.
C++ 또한 multiset의 lower_bound를 통해 구할 수 있다.
어차피 둘이 똑같은 이진검색트리이므로 이런 메서드들도 비슷할 것이다.

다음으로는 메서드를 써서 구한 가방이 null이 아닌 경우,
ans에 해당 보석의 가격을 그냥 더한 다음, 해당 가방을 사용했다는 처리를 해 준다.
C++의 경우 multi"SET"이라서 그냥 해당 가방을 지워버리면 되는데,
우리는 그걸 Tree"Map"으로 구현하고 있기 때문에 이전에 풀었던 이중 우선순위 큐처럼 처리해줘야 한다.
가방의 무게를 key값으로 쓰고 있으니, 해당 가방의 value가 1이라면 remove로 키값을 지워버리고, 그게 아니라면 -1을 해 준다.

끗!


<주의사항>
1. kotlin의 경우, 본인이 지금 TreeMap을 쓰고 있다는 자각을 한 상태로 문제를 푸는 게 좋다. null에 민감해서 계속 오류를 내다보면 뭘 하고 있었는지 기억나지 않을 때가 있더라. 그 부분을 조심하는 게 좋다.
그리고 절대 .plus와 .minus를 그냥 사용해서는 안 된다.
bagMap[iterBag.key]!!.minus(1)는 a = a - 1이 아니라 a - 1만 적은 것이다.
그냥 가산이 안 되는, 아무 기능이 없는 수준의 코드가 된다.


2. ans에는 값이 계속 더해진다. 그런데 보석의 값어치는 최대 백만이고, 갯수는 최대 30만이다. 그 말은 즉, 최대 300,000,000,000. 한 3조까지는 들어가야 한다는 것이다. 그러니까 ans의 값은 반드시 Long같은 64비트 정수로 만들어줘야 한다. 7%에서 틀렸습니다가 뜨는 사람이라면 반드시 체크해봐야 한다.



<제출>
처음은 남들처럼 7%에서 죽길래, 주의사항 2번을 상기하고 그 부분을 고쳐주었다.
그 다음에도 똑같이 틀리길래, 보석 배열의 정렬 방식을 좀 고쳐줬다.
하지만 세 번째 제출에서도 7% 실패이길래...나는 이 문제가 뭔가 잘못되었다고 생각하고 그냥 꺼버렸다.


이후 10일 뒤인 11월 6일.
보석놈을 반드시 깨버리겠다는 마인드로 이것저것 시도해보다가,
큰 수 테스트를 위한 두 번째 예제에서 55억이라는 숫자가 나온다는 걸 알았다.
처음에는 별 생각 없이 넘겼다가, 잘 생각해보니 가방에 숫자 5개를 담는데 1~10까지 모두 더한 숫자가 나올리가 없다 생각해서 자세히 디버깅해보니...

bagMap[iterBag.key]!!.minus(1)
27번째 줄의 이 부분이 아예 기능을 하지 않고 있었다는 것을 알았다.
주의사항 1번을 그 때 깨달은 것이다.
세 번째 예제가 그걸 가려내기 위해서 만들었던 것인데, 알고보니 가방 갯수와 보석 갯수가 같아서 전혀 판별해내지 못하는 것이었다.

이걸 고치자마자 바로 정답이 떴다.
억까가 아닌가 싶지만....그냥 그러려니하기로 했다.


<예제>
가장 기본적인 예제
7 4
5 65
5 23
2 99
4 99
2 41
7 99
0 10
1
5
6
2
99 + 99 + 65 + 10 = 273



같은 갯수의 가방이 여러 개 있는 경우 어떻게 되는가?
10 7
5 100000000
5 200000000
5 300000000
5 400000000
5 500000000
5 600000000
5 700000000
5 800000000
5 900000000
5 1000000000
1
2
5
5
5
6
7
ans : 4000000000


4 4
1 100
2 200
13 300
10 500
10
10
10
14












