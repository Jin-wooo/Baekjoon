<Barking님의 알고리즘 강의로 풀게 된 문제>
https://www.acmicpc.net/problem/1926

풀기 시작한 건 한참 되었는데...
이제서야 답을 제대로 제출하게 된 문제.
진짜 쉬운 문제인데, 몬가 좀 헷갈리고, 문제도 좀 이상하게 꼬아서 풀고 그랬던 것 같다.

도화지에 여러 그림들이 있는데, 이들의 갯수와 가장 넓은 그림의 넓이를 구하는 것이 문제였다.
사실 BFS면 되는 문제다. DFS는.... 생각해보니 좀 안어울린다. DFS여도 못 푸는 건 아니겠으나 넓이를 빠르게 탐색하고 끝내는 편이 훨씬더 좋아보인다.


쪼금 쪽팔리긴 한데, 이 문제는 3번 제출하고 틀렸다.
좀 어처구니 없게.

처음에는 아무 생각없이 →↓방향만 탐색하면 된다는 멍청한 생각을 하고 풀었다.
지금 생각해보면 되게 이상한데....암튼 그랬다.
그런데 그런 멍청한 풀이방식이 정상 작동할 리가 없지...ㅎ

그래서 사방을 탐색하는 걸로 다시 바꿔주었다.
그러고 처음 제출해봤는데 1트는 탈락.
원인을 좀 생각해봤는데...

앞에서 ↓→ 방향만 탐색한다고 가정해서 리스트의 사이즈를 딱 501정도로만 만들었던 게 생각이 났다.
저렇게 하면 0,0에서 위쪽을 탐색하면 -1,0같은 게 나와버리기 때문에 곤란해진다. (이상하게 인덱스가 범주를 넘어갔는데 평소처럼 인덱스에러가 안떴다.)

그래서 그 부분을 고쳐서 listDraw와 listVisit을 502칸으로 맞춰 인덱스 문제를 막고, 거기에 대입하는 부분도 전부 1부터 시작하게 만들어두었다.


그렇게 2트를 하니, 그것도 실패.
3트는 지금 보니 아무런 수정도 거치지 않고 머릿속으로 생각만 하다가 제출한 모양이다. 제대로 미쳤나본데 ㅋㅋㅋㅋㅋㅋㅋㅋ




그리고 4트로 가기 전에 잠시 고민을 해보았다.
뭐가 문제인지 차근차근 디버깅을 조졌지.

처음 보인 문제는 visit이 꼬인다는 거였다.
그림을 처음 발견하면 큐에 넣고 그림을 탐색하는 부분이 if문부터 시작하는데,
그 '그림 하나를 처음 발견'한 부분에는 visit을 찍어두지 않았었다.
이러면 넓이를 계산할 처음 발견한 부분의 위치를 다시 방문하게 된다.
이건 적당히 Push할 때 visit 표시도 남기도록 수정했다.
근데 고치고 돌리니까 오히려 넓이가 잘못 계산되었다.
뭔가 싶어서 디버깅을 다시 돌려봤는데, 치명적인 문제가 하나 있었다.

바로 pair의 순서가 꼬인 문제였다.

38번 줄에서 1을 처음 발견하면
queDot.push(pair<int, int>(x, y));
이런 식으로 넣었는데,
이후 다른 1을 큐에 넣을 때는 
queDot.push(pair<int, int>(tmpY, tmpX));
이런 식으로 넣었었다.
그래, y랑 x의 순서가 바뀌었다.

저거랑 visit 좀 손봐주니 바로 성공했다.


이렇게 쉬운 걸 어쩌다가 이렇게 힘들게 풀게 된건지 잘 모르겠다.