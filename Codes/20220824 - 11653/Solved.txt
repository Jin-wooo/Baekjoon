<BarkingDog님의 알고리즘 강의로 풀게 된 문제>
https://www.acmicpc.net/problem/11653

숫자를 주면 그 수를 소인수분해하는 문제.
분해한 결과값은 한 줄에 하나씩 오름차순 정렬로 출력한다.

결국 소인수분해를 어떻게 하는지가 중요하다고 본다.
나는 소인수분해라길래 해당 숫자의 제곱근 이하의 숫자 중에서 소수를 찾아서 구하는건가? 하는 생각이 들었었다.
그냥 에라스토테네스의 체를 쓰고, 그 이하로 구하는 거지.

근데 또 좀 생각해보니, 체를 다 친 다음에 그걸 다시 순회하면서 계산하는 게 시간에 맞을까? 하는 생각도 들었다.
이후 문제를 좀 보니, 에라스토테네스의 체를 쓰기엔 숫자의 범위가 좀 컸다.
어제 풀었던 체 문제에 비해 범위가 10배 더 크니...좋은 방법은 아닌 걸로.


그래서 그냥 barkingDog님의 강의를 계속 봤었다. 이번 문제는 워낙 쉽다보니 barkingDog님이 그냥 쉽고 빠른 소인수분해의 원리를알려주고 코드를 짜보라고 했었다. 그 방법으로 제시한 게 바로 입력된 수를 나눠줄 수를 2부터 1씩 증가시키면서 나누어떨어지지 않을 때까지 나눠주고, 나눠지면 그 수를 저장하는 방식으로 작업하는 것이다.

이 방법을 처음 들었을 때는, 당연하겠지만 이게 정말로 가능한 건지 의구심이 들었다. 근데 조금만 더 생각해보면 바로 가능하다는 걸 알 수 있다.

barkingDog님은 이 방법에서 궁금할만한 점으로 "정말 목록의 수들을 곱하면 입력값이 나오는가?"와 "목록에 둔 수들이 정말 소수로만 이뤄졌는가?" 정도를 소개해주셨다.
우선 1번의 경우 나눠지면 바로 그 수를 목록에 추가하니까 그렇게 될 수 밖에 없다.
그런데 2번의 경우 조금 복잡한데, 결론적으로는 반드시 소수만 추가된다.
만약 목록에 소수가 아닌 수가 추가된다면, 그 수는 소수가 아니니까 합성수인데, 그렇다면 그 수에는 자기 자신보다 작은 약수를 반드시 포함할 것이고, 그렇다면 그 소수가 먼저  나누어떨어질때까지 나눠버렸을 것이다.
결론적으로는 이 합성수가 입력값을 나누려고 하기 전에 합성수보다 작은 소수들이 먼저 전부 다 나눠버리므로 합성수가 목록에 추가되는 것은 있을 수 없다.

암튼, 위의 이론을 써서 값을 구하면 된다. 구현도 엄청 쉽고 빠르게 되니까 그냥 한번 해보면 된다.


<코드 설명>
입력을 받은 다음, cnt * cnt <= target으로 while문을 돌린다. 이 부분은 소수판정할 때랑 동일하다.
그리고 while문을 통해 tmpTar를 cnt로 나눌 수 없을 때까지 계속 나눠준다.
그리고 나눠지면 그 값을 bw에 기록한다.

이후 tmpTar 변수가 1이 아니라면 tmpTar의 값도 bw에 기록한다. ----1

그러고 출력하면 끗



<주의사항>
1. cnt를 1씩 증가시키면서 잘 나누다가 while문이 끝나는 경우, tmpTar는 두 가지 경우를 맞이하게 된다. 1이거나, 1이 아니거나. 1인 경우 소인수들이 전부 입력값의 제곱근 이하로 잘 나와서 더 이상 할 게 없어진 경우이다. 이 경우에는 1은 무시하고 그냥 지금까지 잘 작성했던 소인수들을 출력하기만 하면 된다. 하지만 1이 아닌 경우, 입력값의 제곱근 이상의 소수가 남은 경우가 많다. 이 수는 애초에 소수이기도 하고, 추가로 나눠줄 수도 없기 때문에 그냥 출력하면 된다. 그래서 출력 전에 tmpTar가 1이 아니면 남은 수를 출력해주는 것이다. 이 부분이 궁금하다면 9991을 입력값으로 두고 디버깅을 해 보면 된다.


